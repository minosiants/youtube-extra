<html>
<header>
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css"
          href="https://raw.githubusercontent.com/arcticicestudio/nord/develop/src/nord.css">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@1.22.0/build/global/luxon.min.js"></script>
    <style type="text/css" media="screen">
			html, body, div, span, applet, object, iframe,
		h1, h2, h3, h4, h5, h6, p, blockquote, pre,
		a, abbr, acronym, address, big, cite, code,
		del, dfn, em, img, ins, kbd, q, s, samp,
		small, strike, strong, sub, sup, tt, var,
		b, u, i, center,
		dl, dt, dd, ol, ul, li,
		fieldset, form, label, legend,
		table, caption, tbody, tfoot, thead, tr, th, td,
		article, aside, canvas, details, embed,
		figure, figcaption, footer, header, hgroup,
		menu, nav, output, ruby, section, summary,
		time, mark, audio, video {
		margin: 0;
		padding: 0;
		border: 0;
		font-size: 100%;
		font: inherit;
		vertical-align: baseline;
		}
		/* HTML5 display-role reset for older browsers */
		article, aside, details, figcaption, figure,
		footer, header, hgroup, menu, nav, section {
		display: block;
		}
		body {
		line-height: 1;
		}
		ol, ul {
		list-style: none;
		}
		blockquote, q {
		quotes: none;
		}
		blockquote:before, blockquote:after,
		q:before, q:after {
		content: '';
		content: none;
		}
		table {
		border-collapse: collapse;
		border-spacing: 0;
		}
		html{
			font-size: 16px;
		}
		body {
			font-family: Roboto, Arial, sans-serif;
			background-color: #2e3440 ;
			color: #e5e9f0;
			margin: 3rem;
			line-height: 1.5rem;
		}
		.container{
			width: 80%;
			margin: 0 auto;
		}
		h1{
			font-size: 2.3rem;
			margin:  1rem 0;
			padding: 1rem 0 ;
		}
		h3{
			font-size: 1.5rem;
			
		}
		a{
			text-decoration: none;
			color: #e5e9f0;
			}
		.thumbnail-video{
			float: left;
			display: inline;
			position: relative;
		}
		.thumbnail-video-duration{
			background:#2e3440 ;
			position: absolute;
			bottom: 1rem;
			right: 1rem;
			padding: 0.5rem 1rem;

		}
		.thumbnail-description{
			float: left;
			display: inline;
			padding-left: 1rem;
			width: 50%
		}
		.description-item{
			padding-bottom: 1rem;
		}
		.sorting-menu:after, .statistics-block:after, .thumbnail:after{
			content: "";
			display: table;
			clear: both;
		}
		.published-at{
			color: #81a1c1;
		}
		.label{
			margin-right:0.2rem;
		}
		.statistics-block li{
			float: left;
			margin-right:1rem;
		}
		.statistics-block{
			margin-top:1rem;
			color: #d08770;
			font-weight: bold;
		}
		.item {
			border-top: 1px solid #4c566a;
			border-bottom: 1px solid #4c566a;
			padding-top:1rem;
			padding-bottom:1rem;
		}
		.sorting-menu li{
			float: right;
			margin: 1rem 0 1rem 1rem;

		}

		.sorting-menu li a{
			padding: 0.5rem;

		}

		.selected {
			background-color: #e5e9f0 ;
			color: #2e3440;
		}

    </style>
    <script type="text/javascript">
			const playlist = JSON.parse('{"playlistInfo":{"id":"PL7DZ7q3nEWhzLs7nLb57N75EY4py_P7pI","snippet":{"publishedAt":"2018-10-10T15:46:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"LambdaConf 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/sddefault.jpg","width":640,"height":480}},"channelTitle":"LambdaConf"}},"videos":[{"id":"lc4IjR1iJTg","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:40Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Aaron Hsu - Parallel-by-construction Tree Manipulation with APL (Part 1) - λC 2018","description":"High-productivity, High-performance, Parallel-by-construction Tree Manipulation with APL - Part 1","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M29S","dimension":"2d"},"statistics":{"viewCount":"1278","likeCount":"11","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"X5_5MtOYNos","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Aaron Hsu - Parallel-by-construction Tree Manipulation with APL (Part 2) - λC 2018","description":"High-productivity, High-performance, Parallel-by-construction Tree Manipulation with APL - Part 1","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H6M35S","dimension":"2d"},"statistics":{"viewCount":"209","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"T-MngXNbrIE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-10-10T18:50:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - Book Of Monads: An Interview -  λC 2018","description":"https://www.amazon.com/Book-Monads-practice-applied-problems-ebook/dp/B07JNZHYLT","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT21M54S","dimension":"2d"},"statistics":{"viewCount":"144","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"SMj-n2f7wYY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:11Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Adam McCullough - Monad Transformers for the Easily Confused - λC 2018","description":"Monads are not composable. This poses a problem, since composition is one of the foremost patterns in functional programming. However, many alternatives have been devised. One of the most common is the monad transformer.<br/><br/>Monad transformers allow developers to compose the effects of different monads, even if the monads themselves are not the same. An example is writing a do-statement that can: abort computation (ExceptT), thread state (StateT), and connect to a database (via a Haskell library such as persistence or esqueleto).<br/><br/>The transformers package is used by over 2,500 packages on Stackage. But using monad transformers is a challenge for many, even if they are already writing useful, effectful, production Haskell.<br/><br/>This talk hopes to de-mystify monad transformers by giving both theoretical and practical code examples. We will start with small examples, to develop an intuition for how they work, and evolve that understanding until we are working with a functional web app that talks to a SQLite back end.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M29S","dimension":"2d"},"statistics":{"viewCount":"1938","likeCount":"34","dislikeCount":"8","favoriteCount":"0","commentCount":null}},{"id":"JFdxrOBtHbE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:58Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - Guarded Impredicativity -  λC 2018","description":"Take a simple expression such as `[id, id]`. Most functional languages, based on Hindley-Milner typing, assign it the type `[a -} a]`. But we could also say, why not assign the type `[forall a. a -} a]`? It turns out that this feature called &quot;impredicative instantiation” is quite complicated to support in modern languages. Theoretically, it is impossible to guarantee 100% perfect inference, and we have been looking for years for a system which is expressive enough yet easy to use. Impredicativity is not very common, so I guess we haven&#39;t found the holy grail yet. <br/><br/>In this talk, I want to propose a new alternative: guarded impredicativity. The idea is simple: you can use a function with an impredicative type only if the `forall` appears inside a type constructor. In other words, if the `forall` is &quot;guarded.&quot; I think that this restriction is easy to understand, but it does not make the life of programmers much harder than it ought to be.<br/><br/>In addition to explaining my contribution, I will introduce the general idea of higher-rank and impredicative types and give an overview of what previous literature has to say about the topic.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT39M59S","dimension":"2d"},"statistics":{"viewCount":"125","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Ieep2RhmCVA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:44:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - A Hands on Tutorial to Generic Programming in Haskell (Part 2) -  λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M37S","dimension":"2d"},"statistics":{"viewCount":"183","likeCount":"0","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"R3HWy1NCXMs","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:44:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - A Hands on Tutorial to Generic Programming in Haskell (Part 1) -  λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M49S","dimension":"2d"},"statistics":{"viewCount":"433","likeCount":"1","dislikeCount":"2","favoriteCount":"0","commentCount":null}},{"id":"7xAaVZD8hpQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - What is a (side) effect? -  λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/side-effects.pdf<br/><br/>In the functional programming community we often argue about the advantages of keeping side effects apart from pure code. But, do we really understand what side effects, or even simply effects, are? In this talk we shall have a look at several of the proposals to handle effects, with the aim of understanding their intricacies.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M33S","dimension":"2d"},"statistics":{"viewCount":"680","likeCount":"17","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3FoKFLfElMo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alex Berg - Some Context for Pure FP Concepts and Style: A Retrospective - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M25S","dimension":"2d"},"statistics":{"viewCount":"209","likeCount":"5","dislikeCount":"3","favoriteCount":"0","commentCount":null}},{"id":"oRTlbblqxWU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 6) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","Haskell"]},"contentDetails":{"duration":"PT1H30S","dimension":"2d"},"statistics":{"viewCount":"262","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"a9_NCwbxZqg","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 5) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H13S","dimension":"2d"},"statistics":{"viewCount":"173","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ewM3NRsOxm4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 4) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M44S","dimension":"2d"},"statistics":{"viewCount":"186","likeCount":"6","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"7P0aCM5mm80","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M3S","dimension":"2d"},"statistics":{"viewCount":"354","likeCount":"7","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"KTyg-52T9i4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:39Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 2) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT49M10S","dimension":"2d"},"statistics":{"viewCount":"467","likeCount":"14","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"2bPRvmoIGi0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:43Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind Glasgow Haskell Compiler Internals (Part 1) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M42S","dimension":"2d"},"statistics":{"viewCount":"1546","likeCount":"31","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"5zRkUhcs7PA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 6) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT23M33S","dimension":"2d"},"statistics":{"viewCount":"85","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"a_CVCA2O4l0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:09Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 5) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT25M9S","dimension":"2d"},"statistics":{"viewCount":"29","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"C7ImHqsKq4k","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 4) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT20M56S","dimension":"2d"},"statistics":{"viewCount":"30","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"AiHoLO054qE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:19Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 3) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT31M49S","dimension":"2d"},"statistics":{"viewCount":"58","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"i-H_MqhRQNU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:22Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 2) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M41S","dimension":"2d"},"statistics":{"viewCount":"75","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"0y0EuoToTco","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:26Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 1) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M47S","dimension":"2d"},"statistics":{"viewCount":"269","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Jpt5eLHeZC4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:20Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - Introduction to FP Using Haskell (Part 2) - λC 2018","description":"We will be spending the day learning the fundamentals of Functional Programming (FP) using the Haskell programming language.Â This one day session is targeted to experienced industry programmers who are looking to break into functional programming and develop the rudimentary skills and techniques that enable continued, independent study. A refresher on Haskell syntax will be provided. However, it is highly recommended to practice with the syntax and development tools prior to the workshop in order to obtain the best outcome for the day.<br/><br/>You will be required to bring a suitable development machine (portable) for working through the exercises. You will also need to install the Glasgow Haskell Compiler, version 7.8 or higher, on that machine prior to the day.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT46M55S","dimension":"2d"},"statistics":{"viewCount":"299","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"K1UjjcdBYp0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - Introduction to FP Using Haskell (Part 1) - λC 2018","description":"We will be spending the day learning the fundamentals of Functional Programming (FP) using the Haskell programming language.Â This one day session is targeted to experienced industry programmers who are looking to break into functional programming and develop the rudimentary skills and techniques that enable continued, independent study. A refresher on Haskell syntax will be provided. However, it is highly recommended to practice with the syntax and development tools prior to the workshop in order to obtain the best outcome for the day.<br/><br/>You will be required to bring a suitable development machine (portable) for working through the exercises. You will also need to install the Glasgow Haskell Compiler, version 7.8 or higher, on that machine prior to the day.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M17S","dimension":"2d"},"statistics":{"viewCount":"578","likeCount":"13","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"GPwtT31zKRY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:27Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - An Intuition for List Folds -  λC 2018","description":"In this talk, we go back to first principles, defining and examining the definition for a cons list, then take a look at the ubiquitous right and left fold functions on a list.<br/><br/>The primary focus of this talk is to develop an intuition for how these functions work so that we can best decide when to apply them. Multiple programming languages will be used to help emphasize the independence of the gained intuition. This talk will generally be interactive with the audience as we solve problems and build confidence in applying our new knowledge<br/><br/>Knowing how to apply the various list fold functions is a common question of students of FP. This talk aims to provide a solid, reliable answer to this question. No prior understanding of list folds is necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT52M57S","dimension":"2d"},"statistics":{"viewCount":"333","likeCount":"10","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"2-8gC8ue1GI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:15:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Thomas Honeyman - Designing Flexible Open source Components in Halogen - λC 2018","description":"As developers, we rely on libraries built and battle-tested by others rather than write everything from scratch. As frontend developers, this often means using pre-built components. Components render HTML for you and affect how your web app looks and behaves. They allow some customization via CSS classes or configuration records. This leads to a large API and a complex implementation to allow for as many use cases as possible. Customizing the component to your specific use case can be nearly as costly as writing a new one from scratch. These limitations arise largely because the component performs rendering for you. But what if it didn&#39;t?<br/><br/>The `purescript-halogen-select` library demonstrates another approach. The library provides essential behaviors for selection user interfaces (like dropdowns, typeaheads, and image pickers) as a group of Halogen components. But you won&#39;t find a single render function in the code.Â Instead, with the help of a few `getProps` helpers, you can write your HTML rendering however you&#39;d like. You can freely include your own queries and the library will return them to be run. You can even use any data you want from your parent state in your render functions. The library manages user interaction, state, accessibility, and logic; you are responsible for rendering HTML depending on that state.<br/><br/>This talk will:<br/>- Describe the design and implementation of the `purescript-halogen-select` library. <br/>- Walk through how a company uses it in production to build dropdowns, typeaheads, calendar pickers, and other components.<br/>- Show how you can use props helpers and the `Store` comonad to design open-source Halogen components without limiting users from rendering HTML as they see fit.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT47M39S","dimension":"2d"},"statistics":{"viewCount":"377","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"XKeD5_wEvXI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:21:56Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Steven Syrek - Category Theory for People who Can&#39;t be Bothered to Learn It (Part 2) - λC 2018","description":"Let&#39;s take a different approach to learning about category theory. Instead of ascending a tower of abstractions through diagram chasing and cranial contortions, we&#39;re going to concentrate in this workshop on the payoffs of thinking about your code categorically.<br/><br/>To that end, we&#39;ll explore categorical objects as reusable patterns that provide powerful guarantees to our programs, morphisms as vehicles for more explicitly structuring our code, and the mathematical properties we can take advantage of when our problem solving process is aligned with even the most trivial elements of this deep and sophisticated field. We will also discuss composition, algebraic data types, and the basics of functoriality, all without having to delve into abstruse terminology or memorize precise rules for drawing arrows between dots.<br/><br/>To demonstrate the universality of this process, we will work directly in code, using both JavaScript and Haskell the former, because of its ubiquity and the latter for its expressiveness. By translating back and forth between syntactic dialects of computation, we will see that the underlying idiom is the same. Once you learn the ideas presented in this workshop, you&#39;ll be able to rethink the way you design your code and also teach these concepts to others.<br/><br/>As functional programmers, we are often accused of advocacy for ideas that are too complex or too impractical for working programmers to use. Our seeming obsession with a branch of mathematics that even many mathematicians consider absurd doesn&#39;t help matters.<br/><br/>The contrary position is that FP, with its basis in math and logic, leverages the genuine simplicity and elegance of these formal systems to help us write code that is coherent, consistent, and best of all law-abiding. Although the learning curve can indeed be steep, the longer term benefits in code readability, testability, and maintainability are worth the initial investment.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M59S","dimension":"2d"},"statistics":{"viewCount":"237","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"43hWxtFFV9M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:22:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Steven Syrek - Category Theory for People who Can&#39;t be Bothered to Learn It (Part 1) - λC 2018","description":"Let&#39;s take a different approach to learning about category theory. Instead of ascending a tower of abstractions through diagram chasing and cranial contortions, we&#39;re going to concentrate in this workshop on the payoffs of thinking about your code categorically.<br/><br/>To that end, we&#39;ll explore categorical objects as reusable patterns that provide powerful guarantees to our programs, morphisms as vehicles for more explicitly structuring our code, and the mathematical properties we can take advantage of when our problem solving process is aligned with even the most trivial elements of this deep and sophisticated field. We will also discuss composition, algebraic data types, and the basics of functoriality, all without having to delve into abstruse terminology or memorize precise rules for drawing arrows between dots.<br/><br/>To demonstrate the universality of this process, we will work directly in code, using both JavaScript and Haskell the former, because of its ubiquity and the latter for its expressiveness. By translating back and forth between syntactic dialects of computation, we will see that the underlying idiom is the same. Once you learn the ideas presented in this workshop, you&#39;ll be able to rethink the way you design your code and also teach these concepts to others.<br/><br/>As functional programmers, we are often accused of advocacy for ideas that are too complex or too impractical for working programmers to use. Our seeming obsession with a branch of mathematics that even many mathematicians consider absurd doesn&#39;t help matters.<br/><br/>The contrary position is that FP, with its basis in math and logic, leverages the genuine simplicity and elegance of these formal systems to help us write code that is coherent, consistent, and best of all law-abiding. Although the learning curve can indeed be steep, the longer term benefits in code readability, testability, and maintainability are worth the initial investment.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT44M42S","dimension":"2d"},"statistics":{"viewCount":"333","likeCount":"7","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"tfG7T54MhIU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:25:17Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephen Pimentel - Propositions as Types for Beginners in Haskell - λC 2018","description":"This session is a gentle introduction to &quot;propositions as types,&quot; also known as the Curry-Howard isomorphism, aimed at beginners in Haskell. Its purpose is practical rather than theoretical: to build intuitions for thinking about and coding functions with parametric, polymorphic types.<br/><br/>Propositions as types is a notion that deeply relates the fields of logic and computation. In academia, its often applied to sophisticated logics at the cutting edge of programming language research. However, the core of propositions as types can be easily explained, and it helps us learn an approach to designing Haskell code that starts with types.<br/><br/>While the Haskell type system may seem easy enough to grasp, beginners often find some of its implications confusing. For example, the inverse relation between the generality of a function type and the number of its implementations can seem counterintuitive. Propositions as types will serve as our framework to build up the key intuitions, letting us recast from a logical perspective the common experience of playing type tetris\u009d with GHC.<br/><br/>We&#39;ll start with the basic ideas of propositions as types and programs as proofs, where type inhabitation corresponds to propositional truth and proof normalization to program evaluation. We&#39;ll explain how the correspondence applies to the &quot;sound&quot; subset of Haskell (i.e., without bottom, non-termination, or general recursion). The core of the session will be a series of simple examples of Haskell types for familiar functions involving basic structures like tuples, Maybe, and Either.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT38M10S","dimension":"2d"},"statistics":{"viewCount":"766","likeCount":"23","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"ej-_FUZClWc","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:26:33Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephen Compall - Opaque Types To Infinity - λC 2018","description":"Scala&#39;s type members have many interesting applications. One surprising application to come into use recently has been true newtypes in the Haskell tradition.<br/><br/>The language for declaring the new type\u009d is just a little trick, but a rich language for describing the newtypes relationship with other types waits to be uncovered.<br/><br/>This talk will show attendees how to use a type member to create a simple opaque type, moving on to demonstrate how to progressively reveal\u009d as many facts about the type as the programmer might desire, whether following a traditional subtyping or an FP-native typeclass approach. It will conclude by showing off the new Fix [infinite] type in Scalaz 8, a new Scala encoding for generalized recursion schemes, and explaining why it works.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M41S","dimension":"2d"},"statistics":{"viewCount":"151","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"E-mANbOvzEQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:28:20Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephan Boyer - Proving Theorems and Certifying Programs with Coq - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/Stephan-Boyer-Coq.pdf<br/><br/>Have you ever wanted to formally prove an algorithm correct or a theorem true? This talk will show you how! We&#39;ll cover the fundamentals of computer-assisted theorem proving using Coq, one of the most popular proof assistants. Coq is a functional programming language with a type system that can encode essentially any mathematical proposition.<br/><br/>It is often said that formal verification is difficult. I will argue a more nuanced position: formal verification is tedious, but it need not be any more challenging than the underlying ideas behind the proof itself. Coq is a small language, and you can learn the basics in an hour. Once you&#39;ve mastered the foundations, what you can prove is limited only by the time you&#39;re willing to invest.<br/><br/>Most introductions to Coq survey the landscape from a bird&#39;s-eye view. You start by building proof scripts using high-level &quot;tactics&quot; and later you&#39;re introduced to the actual proofs generated by these tactics. For some, this is a bit too magical. You learn to prove simple theorems but lack intuition for what the tactics are actually doing. That conundrum was frustrating for me when I was learning Coq in graduate school. This talk, in contrast, will feature no magic.<br/><br/>Instead, we will approach Coq from the perspective of a functional programmer. We&#39;ll start with the syntax, which will be familiar to Haskell or ML programmers. We&#39;ll learn how to encode propositional logic in data types, which can be done in any functional language. Then we&#39;ll see how to encode quantifiers using dependent types, which completes the foundation of higher-order logic. Finally, we&#39;ll learn how to automate our proofs using Coq&#39;s tactic language. The more you automate, the shorter and more robust your proofs become!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","Coq"]},"contentDetails":{"duration":"PT55M18S","dimension":"2d"},"statistics":{"viewCount":"113","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dXRggl82brQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:29:34Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Simon Hafner - A Typeclass Primer for OO People - λC 2018","description":"This talk will explain how to connect functions to types using typeclasses. It will mention common use cases, problems, and the implementations of typeclasses in both Scala and Haskell. No prior knowledge of Scala or Haskell is required.<br/><br/>In object-oriented programming, objects consist of three components: data, methods, and state. When written in an FP style, these objects will only consist of data and pure methods. However, there is no requirement for data and methods/functions to stay together, because there&#39;s no associated state.<br/><br/>Because a method/function doesn&#39;t need an attached object anymore, it&#39;s also possible to attach it to the type instead. The concept of attaching different functions to different types, with all the functions of the same signature, is called a typeclass.<br/><br/>A typeclass is a way to declare an API, similar to an interface in Java. It is then implemented for different types. Each implementation is then associated with the corresponding type. This idea will be demonstrated with the Functor typeclass. Typeclasses are also a strict superset of interfaces in terms of implementation power. This will be demonstrated with the Monoid typeclass.<br/><br/>The concept of typeclasses will be applied in two separate use cases: counting words in documents and JSON codecs. Counting words will be based on Monoids, and the JSON codecs will demonstrate the association between types and functions. Each of the examples will also showcase some of the problems with typeclasses.<br/><br/>These use cases will be demonstrated in Scala and Haskell in order to highlight the differences in their implementations of typeclasses. The differences are mostly in the resolution on which function to pick and in the so-called typeclass coherence.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M18S","dimension":"2d"},"statistics":{"viewCount":"180","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"jb7QX-6Y858","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:30:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Seth House - Why JavaScript Programmers Should Learn Algebraic Data Types - λC 2018","description":"The JavaScript ecosystem is awash with slightly differing implementations of the same thing view libraries, MVC frameworks, state management, async helpers, streams, utilities over and over again. JavaScript fatigue is real, and spending time to learn new things is an investment that must be justified.<br/><br/>ADTs provide a unique and concise API of specifically interlocking pieces that allow building complete programs from simple, individual parts. Whole libraries and frameworks can give way to common and well studied and understood concepts. The often repeated and rarely understood or practiced programming mantras of single-responsibility, composition, and abstraction are made explicit and knowable with ADTs.<br/><br/>The goal of this presentation is to excite and encourage developers who have little to no knowledge of ADTs to want to learn. We will focus single-mindedly on practical, everyday problems and demonstrate a working, minimal solution to each problem in plain JavaScript. We will deemphasize, but not avoid, terminology and implementation. Each topic will conclude with next steps and learning resources.<br/><br/>Some of the problems we will cover are: processing pipelines, null checking, error handling, branching logic, async management, merging/reducing, reactive streams, state management, effects management, declarative UIs, and how to apply your own everyday data to all those scenarios in a composable, functional way.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","javascript"]},"contentDetails":{"duration":"PT55M1S","dimension":"2d"},"statistics":{"viewCount":"165","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"gHAn5Xp8XCA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:07Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Sandy Vanderbleek - Athena: A Declarative Language For Proofs In Computer Science - λC 2018","description":"Athena is a modern language for proofs in computer science. It is declarative and not tactic based which makes it stand out among similar languages such as Coq and Isabelle. The syntax and concepts will be introduced at a comfortable pace for anyone familiar with abstract datatypes and pattern matching. As an example application we will do proofs about operations on the Option Type.<br/><br/>Install Athena to follow along at the command line using the instructions here:http://proofcentral.org/athena/1.4/","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M43S","dimension":"2d"},"statistics":{"viewCount":"81","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"49QvM4pTeDY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:01Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ryan Orendorff &amp; Daniel Hensley - Introduction to Linear Type Systems and Linear Haskell - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/LinearTalk_handout.pdf<br/><br/>Many of the current developments in programming language theory and practical coding revolves around demonstrating that certain classes of bugs are not possible within a given program; example bug classes include control flow errors, mismanaged/implicit state, and dereferencing errors. Proving that certain bugs are impossible in a program allows programmers to reason at a higher level of abstraction without the worry of leaky abstractions causing obscure behaviors in their programs.<br/><br/>One particularly vexing class of bugs are those that involve manipulating objects that mutably change within the lifetime of a program, such as enforcing access APIs for external resources and in-place mutable updates. Example bugs include attempting to manipulate a file through a file handler that has been closed and altering the state of some object from multiple threads simultaneously. What makes these bugs challenging to eliminate at compile time is that the information required to determine the lifetime of these objects is not encoded in the type system of most languages.<br/><br/>Linear Haskell is an extension to the Haskell language that uses linear types to eliminate this class of mutable state bugs, which enables the compiler to understand the context in which an object is used relative to other parts of the program or relative to the external world. In this talk we will examine the underlying type theory of Linear Haskell as well as examples of how this extension prevents this class of bugs from occurring. We will compare the type system introduced in Linear Haskell with other methods that aim to solve a similar class of bugs, including monadic approaches and the uniqueness type systems in Idris and Rust. Attendees will leave with an understanding of the inner workings of linear type theory along with practical examples of projects that use linear types.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M35S","dimension":"2d"},"statistics":{"viewCount":"252","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"6KmqkC9puI0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:01Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 6) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT33M17S","dimension":"2d"},"statistics":{"viewCount":"70","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"NgL3FWsxn30","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:08Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 5) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H46S","dimension":"2d"},"statistics":{"viewCount":"52","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dEVbS4pI3aY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H3M46S","dimension":"2d"},"statistics":{"viewCount":"91","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"p0Ecc9Kl3fE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:19Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M13S","dimension":"2d"},"statistics":{"viewCount":"100","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"HNKvwTrp9zQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 2) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT32M11S","dimension":"2d"},"statistics":{"viewCount":"151","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"1nkJGgHktUI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:31Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 1) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M29S","dimension":"2d"},"statistics":{"viewCount":"376","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"qWy0ldhmIxk","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:46Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 6) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT33M5S","dimension":"2d"},"statistics":{"viewCount":"27","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"GgP7504ee8I","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:52Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 5) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M12S","dimension":"2d"},"statistics":{"viewCount":"16","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"YgqZks_ypD0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:57Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 4) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M57S","dimension":"2d"},"statistics":{"viewCount":"27","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"lfT4Ri6cyVU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 3) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M36S","dimension":"2d"},"statistics":{"viewCount":"51","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Ay80PHwOgSo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:09Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 2) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT51M58S","dimension":"2d"},"statistics":{"viewCount":"90","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"9PanQD_lzZw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:16Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 1) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M7S","dimension":"2d"},"statistics":{"viewCount":"407","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3USNLflRRUA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:52Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Robert Kluin - Introducing A Functional Language At Work - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/A%20Developer%E2%80%99s%20Guide%20to%20Introducing%20A%20Functional%20Language%20At%20Work.pdf<br/><br/>Introducing functional programming within an organization is challenging. This talk is a retrospective on two implementations, one an ongoing success and the other a failed attempt. The goal is to help grow our community by expanding the usage of functional languages.<br/><br/>We first attempted to introduce Scala. We quickly discovered the reasons we used to justify choosing Scala were actually challenges that led to us abandoning the effort. We selected the perfect technical problem for the language to demonstrate its value. The flexibility of the language, build tooling, and the runtime architecture became liabilities. In hindsight, the problems we faced should have been expected.<br/><br/>We firmly believed in the merits of functional languages, so we reflected on our prior failure and decided to try again. We chose a language no one was as excited about: Elm. The team was a semi-reluctant guinea pig, but they quickly became Elm evangelists. The team&#39;s pace of delivery and low defect rate validated our decision to try introducing another functional language.<br/><br/>Comparing these two projects will help guide the introduction of not only new functional programming languages, but new technologies in general. The takeaways include insights into selecting the right pilot projects and teams, and how ancillary technologies will impact your chances of success.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT42M10S","dimension":"2d"},"statistics":{"viewCount":"100","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"4IPXSj5NVxQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:33:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Reid Evans - Abstract Algebras and Where to Find Them  Magmas, Monoids, and More! - λC 2018","description":"The structures of abstract algebra appear over and over again in the real world from the simple addition of numbers and string concatenation to modular architectural patterns for large enterprise systems and beyond. The best part about these abstractions is that we can leverage the simpler examples to begin building an intuition for the larger examples. So what are magmas? Other than alliteration, what do they have in common with monoids? This presentation will give you the skills needed to begin spotting these structures in the wild, as well as tips for using them to solve problems large and small.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M6S","dimension":"2d"},"statistics":{"viewCount":"175","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"vhKNBISDycw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:34:10Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Pawel Szulc - Understanding Distributed Calculi in Haskell - λC 2018","description":"In the late 1960s, it was already a well-established fact that any arbitrary, complex programming language can be represented as an evidently tinier &quot;core&quot; language. Lambda calculus, or Turing machines, are the most well-known examples of such languages. However, they all shared a common constraint: the ability to model only sequential computations. With the rise of distributed systems and multicore architectures, industry has needed a new formalism to represent calculations that run concurrently. This talk is an introduction to process calculus, a family of related formalisms that model concurrent systems. They describe high-level interactions between a collection of independent processes and also algebraic laws that allow process descriptions to be analyzed and their equivalences reasoned about.<br/><br/>This talk describes in detail two process calculi: pi Calculus and its natural successor rho calculus. A Haskell library called distributed-process (also known as Cloud Haskell) will be used to show live code examples. Cloud Haskell is a library which allows message-passing programming style, similar to the one known in Erlang or Akka (Scala). Attendees should be familiar with simple Haskell syntax and lambda calculus, however some limited introduction to both the language and the formalism will be covered, as well.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","haskell","distributed computing"]},"contentDetails":{"duration":"PT47M9S","dimension":"2d"},"statistics":{"viewCount":"152","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"8_HsFrXhZlA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:34:42Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Paul Snively - Typed FP on the Job  Why Bother - λC 2018","description":"Good news: your organization&#39;s management team has expressed a willingness to explore functional programming with a statically-typed language. Bad news: neither they nor anyone else on your team has any deep experience with functional programming. Worse news: some members of your team are perfectly happy with your language, techniques, codebase, and processes and are skeptical at best, and outright hostile at worst, to functional programming. Your front-end developers, in particular, don&#39;t see the point of static typing. Intellectual honesty compels us to admit that pure typed FP has some significant up-front costs, especially when you include the inevitable learning curve. Your colleagues want to know: why bother?<br/><br/>It&#39;s a legitimate question, especially since your team is probably not in the pure typed FP business for its own sake. Fortunately, the question has an answer. We&#39;ll explore and unpack that answer and some of the implications of doing pure typed FP that inform it. Most examples will be drawn from the speaker&#39;s experience with pure typed FP in Scala, but the concepts we&#39;ll explore apply equally well to any pure typed approach to FP, such as in Haskell or PureScript.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT38M57S","dimension":"2d"},"statistics":{"viewCount":"535","likeCount":"16","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"hR2yX9fWQ7A","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:35:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikolai Kudasov - Building a Telegram Bot in Haskell (Part 2) - λC 2018","description":"Telegram is a popular messenger with a fairly easy way to construct and use bots. Bots are used to provide lightweight interfaces to many services or to help with various repetitive tasks. For instance, you can make a bot to keep track of your budget or work time, provide you a personalized news feed, monitor your GitHub repo activity, or simply make a conversation! Some even use a Telegram bot as a cryptowallet interface!<br/><br/>The Telegram Bot API makes it relatively easy to write a bot in virtually any programming language. And Python is a popular choice for this. However, I find Haskell to be more comfortable to write a bot in. A typical bot relies on some conversation state machine and handles many conversations concurrently, and Haskell allows a very simple yet powerful encoding of that logic.<br/><br/>In this workshop, you&#39;ll learn how to develop a simple Telegram bot with features like commands, notifications, custom keyboards, on-the-fly updating and inline mode. In the process, you will see what a development experience in Haskell may look like with just a minimal set of tools like Stack, GHCi, and ghcid.<br/><br/>The workshop assumes some basic Haskell knowledge. Ability to understand (simple) GHC error messages will help a great deal. Familiarity with applicative parsers might also help to better understand the bot&#39;s input processing, however, it&#39;s not at all necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M59S","dimension":"2d"},"statistics":{"viewCount":"190","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dfTTgdlsSzo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:35:26Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikolai Kudasov - Building a Telegram Bot in Haskell (Part 1) - λC 2018","description":"Telegram is a popular messenger with a fairly easy way to construct and use bots. Bots are used to provide lightweight interfaces to many services or to help with various repetitive tasks. For instance, you can make a bot to keep track of your budget or work time, provide you a personalized news feed, monitor your GitHub repo activity, or simply make a conversation! Some even use a Telegram bot as a cryptowallet interface!<br/><br/>The Telegram Bot API makes it relatively easy to write a bot in virtually any programming language. And Python is a popular choice for this. However, I find Haskell to be more comfortable to write a bot in. A typical bot relies on some conversation state machine and handles many conversations concurrently, and Haskell allows a very simple yet powerful encoding of that logic.<br/><br/>In this workshop, you&#39;ll learn how to develop a simple Telegram bot with features like commands, notifications, custom keyboards, on-the-fly updating and inline mode. In the process, you will see what a development experience in Haskell may look like with just a minimal set of tools like Stack, GHCi, and ghcid.<br/><br/>The workshop assumes some basic Haskell knowledge. Ability to understand (simple) GHC error messages will help a great deal. Familiarity with applicative parsers might also help to better understand the bot&#39;s input processing, however, it&#39;s not at all necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M9S","dimension":"2d"},"statistics":{"viewCount":"755","likeCount":"16","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ZMC3MQCxvME","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:36:27Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikhil Barthwal - Cross Platform Mobile Application Development with F# - λC 2018","description":"F# is a relatively new, primarily functional programming language for the .NET platform. It is a statically-typed, managed functional language that is fully interoperable with other .NET languages like C#, Visual Basic.NET, etc. It builds on the power of the functional paradigm and combines it with the .NET object-oriented model, enabling the developer to use the best approach for a given problem. F# offers all the benefits of functional programming (FP), such as terse code leading to enhanced developer productivity, pure functions which are much easier to reason about, and side-effect free programming that eliminates a large class of bugs.<br/><br/>Xamarin platforms allows you the build mobile apps using F# with high code re-use between them. Typically, there is common code, which is where more of the app-specific logic resides, and then specific features of the platform can be leveraged using platform specific code (also in F#). Xamarin offers platform-specific mappings for iOS and Android as .NET libraries that F# code can use, and applications are compiled as either a .app file in iOS, or .apk file in Android.<br/><br/>This talk goes into the details of how the Xamarin platform works and will teach attendees how to build native apps for multiple platforms using a single F# code base.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M17S","dimension":"2d"},"statistics":{"viewCount":"251","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"lc4IjR1iJTg","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:40Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Aaron Hsu - Parallel-by-construction Tree Manipulation with APL (Part 1) - λC 2018","description":"High-productivity, High-performance, Parallel-by-construction Tree Manipulation with APL - Part 1","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/lc4IjR1iJTg/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M29S","dimension":"2d"},"statistics":{"viewCount":"1278","likeCount":"11","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"X5_5MtOYNos","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Aaron Hsu - Parallel-by-construction Tree Manipulation with APL (Part 2) - λC 2018","description":"High-productivity, High-performance, Parallel-by-construction Tree Manipulation with APL - Part 1","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/X5_5MtOYNos/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H6M35S","dimension":"2d"},"statistics":{"viewCount":"209","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"SMj-n2f7wYY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:45:11Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Adam McCullough - Monad Transformers for the Easily Confused - λC 2018","description":"Monads are not composable. This poses a problem, since composition is one of the foremost patterns in functional programming. However, many alternatives have been devised. One of the most common is the monad transformer.<br/><br/>Monad transformers allow developers to compose the effects of different monads, even if the monads themselves are not the same. An example is writing a do-statement that can: abort computation (ExceptT), thread state (StateT), and connect to a database (via a Haskell library such as persistence or esqueleto).<br/><br/>The transformers package is used by over 2,500 packages on Stackage. But using monad transformers is a challenge for many, even if they are already writing useful, effectful, production Haskell.<br/><br/>This talk hopes to de-mystify monad transformers by giving both theoretical and practical code examples. We will start with small examples, to develop an intuition for how they work, and evolve that understanding until we are working with a functional web app that talks to a SQLite back end.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/SMj-n2f7wYY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M29S","dimension":"2d"},"statistics":{"viewCount":"1938","likeCount":"34","dislikeCount":"8","favoriteCount":"0","commentCount":null}},{"id":"R3HWy1NCXMs","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:44:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - A Hands on Tutorial to Generic Programming in Haskell (Part 1) -  λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/R3HWy1NCXMs/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M49S","dimension":"2d"},"statistics":{"viewCount":"433","likeCount":"1","dislikeCount":"2","favoriteCount":"0","commentCount":null}},{"id":"Ieep2RhmCVA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:44:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - A Hands on Tutorial to Generic Programming in Haskell (Part 2) -  λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Ieep2RhmCVA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M37S","dimension":"2d"},"statistics":{"viewCount":"183","likeCount":"0","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"JFdxrOBtHbE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:58Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - Guarded Impredicativity -  λC 2018","description":"Take a simple expression such as `[id, id]`. Most functional languages, based on Hindley-Milner typing, assign it the type `[a -} a]`. But we could also say, why not assign the type `[forall a. a -} a]`? It turns out that this feature called &quot;impredicative instantiation” is quite complicated to support in modern languages. Theoretically, it is impossible to guarantee 100% perfect inference, and we have been looking for years for a system which is expressive enough yet easy to use. Impredicativity is not very common, so I guess we haven&#39;t found the holy grail yet. <br/><br/>In this talk, I want to propose a new alternative: guarded impredicativity. The idea is simple: you can use a function with an impredicative type only if the `forall` appears inside a type constructor. In other words, if the `forall` is &quot;guarded.&quot; I think that this restriction is easy to understand, but it does not make the life of programmers much harder than it ought to be.<br/><br/>In addition to explaining my contribution, I will introduce the general idea of higher-rank and impredicative types and give an overview of what previous literature has to say about the topic.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/JFdxrOBtHbE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT39M59S","dimension":"2d"},"statistics":{"viewCount":"125","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"7xAaVZD8hpQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - What is a (side) effect? -  λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/side-effects.pdf<br/><br/>In the functional programming community we often argue about the advantages of keeping side effects apart from pure code. But, do we really understand what side effects, or even simply effects, are? In this talk we shall have a look at several of the proposals to handle effects, with the aim of understanding their intricacies.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/7xAaVZD8hpQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M33S","dimension":"2d"},"statistics":{"viewCount":"680","likeCount":"17","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3FoKFLfElMo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:43:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alex Berg - Some Context for Pure FP Concepts and Style: A Retrospective - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3FoKFLfElMo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M25S","dimension":"2d"},"statistics":{"viewCount":"209","likeCount":"5","dislikeCount":"3","favoriteCount":"0","commentCount":null}},{"id":"wCiu_UAm2Ec","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:59Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alex Berg - TEA and SPA: A Retrospective -  λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/wCiu_UAm2Ec/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/wCiu_UAm2Ec/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/wCiu_UAm2Ec/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/wCiu_UAm2Ec/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT29M58S","dimension":"2d"},"statistics":{"viewCount":"113","likeCount":"1","dislikeCount":"2","favoriteCount":"0","commentCount":null}},{"id":"_bgsYDPpHYw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:51Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alex Von Hoene - Computation in Graphics Applications - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/_bgsYDPpHYw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/_bgsYDPpHYw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/_bgsYDPpHYw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/_bgsYDPpHYw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT30M5S","dimension":"2d"},"statistics":{"viewCount":"86","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dEqk2Sxq6W8","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:43Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alexander Konovalov - Hands on Chat About Categories - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dEqk2Sxq6W8/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dEqk2Sxq6W8/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dEqk2Sxq6W8/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dEqk2Sxq6W8/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","Category Theory"]},"contentDetails":{"duration":"PT1H10M31S","dimension":"2d"},"statistics":{"viewCount":"149","likeCount":"2","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"BcIffFVyc8U","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:37Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alexander Konovalov - ScalaFiddle and Categories -  λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/BcIffFVyc8U/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/BcIffFVyc8U/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/BcIffFVyc8U/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/BcIffFVyc8U/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT46M50S","dimension":"2d"},"statistics":{"viewCount":"125","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"jcO2P5G3-V8","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:30Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alexander Konovalov - The Leibniz Library and Applied Propositions as Types - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/jcO2P5G3-V8/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/jcO2P5G3-V8/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/jcO2P5G3-V8/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/jcO2P5G3-V8/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H4M2S","dimension":"2d"},"statistics":{"viewCount":"135","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3qnblgj4MYo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:42:06Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Arnaud Baily &amp; Jan Christopher Vogt - Live Coding Eff in Anger - λC 2018","description":"Modularity and extensibility are keys when writing software systems. There exist few options when one wants to write modular, extensible, effectful code in Haskell: basically mtl-style typeclasses and free monad derivatives. Extensible effects, aka the Eff monad, is a solution loosely based on the free monad technique using the freer package for fun and profit. This session is a live-coding, pair-programming introduction to the use of `Eff` to structure an application decoupled in distinct components with strict interfaces. We will interactively develop a simple yet realistic Eff-based Pet Store REST service, demonstrating how to code and test the various effects introduced, how to compose them to produce the desired service, how to leverage the existing standard effects provided by the freer package, and the various ways of writing interpreters and how to handle the sometimes daunting type-checker errors.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3qnblgj4MYo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3qnblgj4MYo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3qnblgj4MYo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3qnblgj4MYo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M44S","dimension":"2d"},"statistics":{"viewCount":"148","likeCount":"1","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"CD5zTkipGqU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:41:44Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Beau Lyddon - Don&#39;t Worry About Monads - λC 2018","description":"Many of us have struggled to pick up functional languages. We&#39;ve been scared off by the terminology: monads, monoids, functors. My goal is to show those afraid to jump in that there is room in the functional world for all of us, no matter your background or skills. I will show how you can not only learn functional languages without understanding those scary terms but that you can even ship production code.<br/><br/>Like many of you, I approached functional programming from an imperative background without much math education. I found that sitting down with the goal of understanding monads got me me nowhere. It wasn&#39;t until I started building applications that I started making progress.<br/><br/>We will start with Elm and show how you can get up and running with a project even more quickly than you can with many of the popular imperative languages. I&#39;ll show how those coming from Python, Ruby, and JavaScript can feel right at home with Elm. Once we are comfortable with the basics of the syntax, we&#39;ll then walk through the Elm architecture and how structuring functional systems are often simpler than it is in object-oriented systems.<br/><br/>To finish, we&#39;ll quickly show how, all along, we were using monads, monoids, and functors without once using the terms. I&#39;ll leave you with quick examples of how Elm can lead you right into strongly-typed functional languages such as Haskell and PureScript.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/CD5zTkipGqU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/CD5zTkipGqU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/CD5zTkipGqU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/CD5zTkipGqU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M44S","dimension":"2d"},"statistics":{"viewCount":"310","likeCount":"4","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"mrOjfDL6Xys","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:40:50Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brad Urani - Elixir&#39;s Ecto: Functional Relational Data Access Done Right - λC 2018","description":"Relational databases provide a challenge for functional programmers: they&#39;re inherently mutable, but they&#39;re still the best choice for many applications due to their guarantees and performance. Fortunately, functional languages like Elixir and the frameworks built around them are reinventing the way we do SQL, and the results are all positive. Join us and learn about Ecto, Elixir&#39;s answer to functional-relational data access. If you&#39;re sick of leaky abstractions, you&#39;ll love how it exposes the database for what it is. If you&#39;re building for the web, you&#39;ll love how its incorporation into the Phoenix web framework is modernizing web development. If you&#39;ve had a bad experience with database abstractions in the past, you won&#39;t want to use anything else. Just don&#39;t call it an ORM.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/mrOjfDL6Xys/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/mrOjfDL6Xys/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/mrOjfDL6Xys/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/mrOjfDL6Xys/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT35M14S","dimension":"2d"},"statistics":{"viewCount":"159","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"xAFawAKjLfA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:40:24Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brandon Kase - Abstract Algebra Driven Design  Animation in Swift as almost Semirings - λC 2018","description":"It&#39;s not immediately clear how to build &quot;nice&quot; libraries. Let&#39;s consider animations: Think of a box flying across an iPhone screen before fading out. How might we design this library? Writing the type first, before the implementation, is known and common in the functional programming community as a method for writing correct code, but is it the right way to build an API? Authors should consider something else even before the type: Composability. How can we make animations compose? We can combine two animations in sequence to produce an animation. And two animations in parallel is an animation, as well. But we shouldn&#39;t stop here. Documenting the laws to which these binary operations conform leads to a better understanding of the domain both for consumers and producers of a library. In this talk, we will introduce algebraic properties: associativity, commutativity, identity, idempotency, distributivity, etc. We will talk about the algebraic structures they induce on a binary operation: semigroup, monoid, commutative monoid, semiring, etc. At every step, we will make the abstract concrete by bringing it back to our animation example.<br/><br/>Only after we fully understand the laws around our animations&#39; composition do we think about the type and the implementation of our animations. This is abstract-algebra-driven design. In Swift, a language without higher-kinded-types, we can still reify our knowledge of algebraic structures into software! Here, we&#39;ll look at an implementation of the animation library we designed earlier. By the end of the talk, it will be clear how to build complex animations out of our simple, lawful, composable primitives. More importantly, we&#39;ll understand basic abstract algebra and its application to API design!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/xAFawAKjLfA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/xAFawAKjLfA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/xAFawAKjLfA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/xAFawAKjLfA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M12S","dimension":"2d"},"statistics":{"viewCount":"235","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"6HnmoE0lOr0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:40:00Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brooklyn Zelenka - Learn Elixir by Building a Real Time CLI Chat App (Part 1) - λC 2018","description":"Elixir is developing a wide audience thanks to its friendly syntax, pragmatic ecosystem, and supportive community. It&#39;s a great way to get OO and imperative teams interested in functional programming. Elixir (and Erlang) are known for their soft-realtime features, but many people are afraid of the core libraries such as GenServer due to how unfamiliar they are.<br/><br/>This workshop is designed to get absolute Elixir beginners familiar with Elixir, how to interact with the ecosystem, understand the actor model, and work with the core libraries such as GenServer. Participants will get up and running with Elixir basics, understand the actor model, and learn about support libraries in Elixir. We will build a fully distributed CLI chat app with little beyond the core libraries, and have the class interact using it. Time permitting, we may build a simple game to run over the network, as well.<br/><br/>Attendees will learn the following concepts:<br/>- Tagged tuples<br/>- Stateless programming<br/>- Supervision trees<br/>- The actor model<br/>- Parametric polymorphism<br/>- Message passing (the Elixir way)<br/><br/>Attendees will develop the following skills:<br/>- Get started with a fresh Elixir project<br/>- How to write a soft-realtime application<br/>- Fault-tolerance<br/>- Testing Elixir<br/>- How to avoid common gotchas<br/>- Modeling systems with processes and actors<br/><br/>Participants will need to have a wifi-capable computer with Elixir 1.6.0+ installed to fully participate","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/6HnmoE0lOr0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/6HnmoE0lOr0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/6HnmoE0lOr0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/6HnmoE0lOr0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT44M34S","dimension":"2d"},"statistics":{"viewCount":"302","likeCount":"8","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"QQ1xJx9OAAw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:39:54Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brooklyn Zelenka - Learn Elixir by Building a Real Time CLI Chat App (Part 2) - λC 2018","description":"Elixir is developing a wide audience thanks to its friendly syntax, pragmatic ecosystem, and supportive community. It&#39;s a great way to get OO and imperative teams interested in functional programming. Elixir (and Erlang) are known for their soft-realtime features, but many people are afraid of the core libraries such as GenServer due to how unfamiliar they are.<br/><br/>This workshop is designed to get absolute Elixir beginners familiar with Elixir, how to interact with the ecosystem, understand the actor model, and work with the core libraries such as GenServer. Participants will get up and running with Elixir basics, understand the actor model, and learn about support libraries in Elixir. We will build a fully distributed CLI chat app with little beyond the core libraries, and have the class interact using it. Time permitting, we may build a simple game to run over the network, as well.<br/><br/>Attendees will learn the following concepts:<br/>- Tagged tuples<br/>- Stateless programming<br/>- Supervision trees<br/>- The actor model<br/>- Parametric polymorphism<br/>- Message passing (the Elixir way)<br/><br/>Attendees will develop the following skills:<br/>- Get started with a fresh Elixir project<br/>- How to write a soft-realtime application<br/>- Fault-tolerance<br/>- Testing Elixir<br/>- How to avoid common gotchas<br/>- Modeling systems with processes and actors<br/><br/>Participants will need to have a wifi-capable computer with Elixir 1.6.0+ installed to fully participate","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/QQ1xJx9OAAw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/QQ1xJx9OAAw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/QQ1xJx9OAAw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/QQ1xJx9OAAw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT23M50S","dimension":"2d"},"statistics":{"viewCount":"91","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Z1ICJ8qASNI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:39:48Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brooklyn Zelenka - Learn Elixir by Building a Real Time CLI Chat App (Part 3) - λC 2018","description":"Elixir is developing a wide audience thanks to its friendly syntax, pragmatic ecosystem, and supportive community. It&#39;s a great way to get OO and imperative teams interested in functional programming. Elixir (and Erlang) are known for their soft-realtime features, but many people are afraid of the core libraries such as GenServer due to how unfamiliar they are.<br/><br/>This workshop is designed to get absolute Elixir beginners familiar with Elixir, how to interact with the ecosystem, understand the actor model, and work with the core libraries such as GenServer. Participants will get up and running with Elixir basics, understand the actor model, and learn about support libraries in Elixir. We will build a fully distributed CLI chat app with little beyond the core libraries, and have the class interact using it. Time permitting, we may build a simple game to run over the network, as well.<br/><br/>Attendees will learn the following concepts:<br/>- Tagged tuples<br/>- Stateless programming<br/>- Supervision trees<br/>- The actor model<br/>- Parametric polymorphism<br/>- Message passing (the Elixir way)<br/><br/>Attendees will develop the following skills:<br/>- Get started with a fresh Elixir project<br/>- How to write a soft-realtime application<br/>- Fault-tolerance<br/>- Testing Elixir<br/>- How to avoid common gotchas<br/>- Modeling systems with processes and actors<br/><br/>Participants will need to have a wifi-capable computer with Elixir 1.6.0+ installed to fully participate","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Z1ICJ8qASNI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Z1ICJ8qASNI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Z1ICJ8qASNI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Z1ICJ8qASNI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT39M29S","dimension":"2d"},"statistics":{"viewCount":"56","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"aQvnsnfTdG4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:39:43Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brooklyn Zelenka - Learn Elixir by Building a Real Time CLI Chat App (Part 4) - λC 2018","description":"Elixir is developing a wide audience thanks to its friendly syntax, pragmatic ecosystem, and supportive community. It&#39;s a great way to get OO and imperative teams interested in functional programming. Elixir (and Erlang) are known for their soft-realtime features, but many people are afraid of the core libraries such as GenServer due to how unfamiliar they are.<br/><br/>This workshop is designed to get absolute Elixir beginners familiar with Elixir, how to interact with the ecosystem, understand the actor model, and work with the core libraries such as GenServer. Participants will get up and running with Elixir basics, understand the actor model, and learn about support libraries in Elixir. We will build a fully distributed CLI chat app with little beyond the core libraries, and have the class interact using it. Time permitting, we may build a simple game to run over the network, as well.<br/><br/>Attendees will learn the following concepts:<br/>- Tagged tuples<br/>- Stateless programming<br/>- Supervision trees<br/>- The actor model<br/>- Parametric polymorphism<br/>- Message passing (the Elixir way)<br/><br/>Attendees will develop the following skills:<br/>- Get started with a fresh Elixir project<br/>- How to write a soft-realtime application<br/>- Fault-tolerance<br/>- Testing Elixir<br/>- How to avoid common gotchas<br/>- Modeling systems with processes and actors<br/><br/>Participants will need to have a wifi-capable computer with Elixir 1.6.0+ installed to fully participate","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/aQvnsnfTdG4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/aQvnsnfTdG4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/aQvnsnfTdG4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/aQvnsnfTdG4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT26M6S","dimension":"2d"},"statistics":{"viewCount":"64","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"D3D8LFKkzPw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:39:38Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Brooklyn Zelenka - Learn Elixir by Building a Real Time CLI Chat App (Part 5) - λC 2018","description":"Elixir is developing a wide audience thanks to its friendly syntax, pragmatic ecosystem, and supportive community. It&#39;s a great way to get OO and imperative teams interested in functional programming. Elixir (and Erlang) are known for their soft-realtime features, but many people are afraid of the core libraries such as GenServer due to how unfamiliar they are.<br/><br/>This workshop is designed to get absolute Elixir beginners familiar with Elixir, how to interact with the ecosystem, understand the actor model, and work with the core libraries such as GenServer. Participants will get up and running with Elixir basics, understand the actor model, and learn about support libraries in Elixir. We will build a fully distributed CLI chat app with little beyond the core libraries, and have the class interact using it. Time permitting, we may build a simple game to run over the network, as well.<br/><br/>Attendees will learn the following concepts:<br/>- Tagged tuples<br/>- Stateless programming<br/>- Supervision trees<br/>- The actor model<br/>- Parametric polymorphism<br/>- Message passing (the Elixir way)<br/><br/>Attendees will develop the following skills:<br/>- Get started with a fresh Elixir project<br/>- How to write a soft-realtime application<br/>- Fault-tolerance<br/>- Testing Elixir<br/>- How to avoid common gotchas<br/>- Modeling systems with processes and actors<br/><br/>Participants will need to have a wifi-capable computer with Elixir 1.6.0+ installed to fully participate","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/D3D8LFKkzPw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/D3D8LFKkzPw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/D3D8LFKkzPw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/D3D8LFKkzPw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT41M9S","dimension":"2d"},"statistics":{"viewCount":"69","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"xJh3rBWcM2c","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:39:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Cary Robbins - Zero Cost Abstractions  Eliminating Runtime Overhead in Scala - λC 2018","description":"Many of the standard abstractions employed today require some level of overhead, usually many new allocations to generate objects so we can perform special operations. We will tackle the following items, leveraging what we learn along the way for future optimizations.<br/>- While AnyVal exists, it&#39;s not quite like Haskell&#39;s newtype. Is it possible to implement something like newtype for Scala?<br/>- Polymorphic typeclass instances must be re-instantiated on every summon. GHC Haskell is smart enough to create these instances only once at compile time; is it possible to do the same in Scala?<br/>- Generic programming via the Shapeless library requires many allocations of HList. Can we do generic programming in Scala without the need for extra runtime allocations?<br/><br/>We will review the design of the newtype library for Scala which demonstrates a pattern and general abstractions for creating and using newtypes. Weâ€™ll also take a look at the Coercible type class as a general solution to efficiently converting between types. Next, we can observe how we can cache instances so we can write efficient polymorphic functions. This approach will be demonstrated simply with the definition of the Either monad. We can expand this principle further to build a @cached macro which takes care of this optimization for us. Finally, we will review the derivable project as an approach to building a zero-cost generic programming library. This leverages some of the tricks we&#39;ve learned along the way, using safe coercions to encode metadata at the type level only, building extractors to access fields without the need to do any data copying whatsoever. Benchmarking our derivable project demonstrates a performance improvement over Shapeless by 20% and performs nearly identically to hand-written code.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/xJh3rBWcM2c/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/xJh3rBWcM2c/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/xJh3rBWcM2c/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/xJh3rBWcM2c/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT51M48S","dimension":"2d"},"statistics":{"viewCount":"556","likeCount":"11","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"d4STRDLzpXI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:38:50Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Chris Allen - Moot - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/d4STRDLzpXI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/d4STRDLzpXI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/d4STRDLzpXI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/d4STRDLzpXI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT4M53S","dimension":"2d"},"statistics":{"viewCount":"122","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"E9pJ71-zdm0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:38:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Chris Allen - The Properties of Property Testing with Hedgehog - λC 2018","description":"Property testing has seen strong growth in the past few years as a cheap and cheerful means of validating program correctness. Once a developer gets beyond basic uses and applications, it becomes necessary to understand how these libraries work in order to use them effectively. A programmer should understand where their random values are coming from and what sort of distribution they fit. Further, practitioners should be comfortable writing generators for their own types<br/><br/>I&#39;ll use Hedgehog as the primary library and point of reference for the talk, but I&#39;ll anchor the explanations of the design against where Hedgehog differs from QuickCheck, the canonical property testing library. I&#39;ll also explain why the Arbitrary typeclass was not carried over in the transition from QuickCheck to Hedgehog. I&#39;ll also relate some experiences I had porting applications and libraries to Hedgehog.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/E9pJ71-zdm0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/E9pJ71-zdm0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/E9pJ71-zdm0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/E9pJ71-zdm0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT47M55S","dimension":"2d"},"statistics":{"viewCount":"191","likeCount":"5","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"UO6nCZfdsuQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:37:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Chris McKinlay - Down the Wabbit Hole - λC 2018","description":"Vowpal Wabbit is a fast, out-of-core C++ implementation of sparse gradient descent. It is sponsored by Microsoft Research and is one of the few open-source libraries capable of solving contextual bandit problems at scale unfortunately it is also a minefield to use properly. Would Haskell bindings make this situation better or worse?<br/><br/>In this talk, we&#39;ll explore how to use brackets and the service pattern to guarantee safe and performant usage of an otherwise unsafe library. Along the way, we&#39;ll learn about some of Haskell&#39;s lower-level language features, including the FFI, IO buffers, and thread pools.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/UO6nCZfdsuQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/UO6nCZfdsuQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/UO6nCZfdsuQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/UO6nCZfdsuQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M41S","dimension":"2d"},"statistics":{"viewCount":"107","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"z8gNYJKPMCQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:36:56Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Christopher Phelps - Testing for Lawful Good Adventures - λC 2018","description":"Practitioners of functional programming often speak about &quot;lawful abstractions.&quot; Whether implementing well-known mathematical concepts or novel ideas, we can define laws to specify constraints on how an abstraction should behave. These allow us a way to prove the correctness of algorithms separate from domain and data details and allow for flexibility and freedom in algorithm implementation.<br/><br/>In this session, we will discuss how laws arise, and see the advantages they provide for both algorithm and data structure implementers. We&#39;ll see how testing the lawfulness of an implementation differs from testing other domain specifics of the implementation. We will look at ways to test the lawfulness of an implementation in Scala. We will see how laws help inform and empower the typeclass pattern and allow for reuse and composition.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/z8gNYJKPMCQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/z8gNYJKPMCQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/z8gNYJKPMCQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/z8gNYJKPMCQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT35M59S","dimension":"2d"},"statistics":{"viewCount":"39","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"-UEOLfyDi74","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:36:30Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Colin Woodbury - How Not to Write Slow Scala - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-UEOLfyDi74/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/-UEOLfyDi74/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/-UEOLfyDi74/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/-UEOLfyDi74/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M19S","dimension":"2d"},"statistics":{"viewCount":"694","likeCount":"10","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"XA9Op0_TgoM","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:36:00Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dan Fithian - Haskell DJs: Compose a Hit with Vinyl! - λC 2018","description":"PureScript has row types, and it&#39;s widely considered to be an excellent feature. Why can&#39;t we have the same thing in Haskell? With Vinyl, and a layer of sugar provided by Composite Records, we can! In this talk, I will introduce row types in Haskell as implemented by the Vinyl library, discuss their utility for API design, and demonstrate how to leverage them to define a JSON spec.<br/><br/>Row types emphasize subsetting as a way of testing equality, downcasting, and translation of types by deleting/injecting fields. These features motivate us to want to use row types throughout our entire program instead of just the internals. However, nobody has written a library to do this until just last year. Composite Records, written in 2017 and inspired by the Frames library, uses row types with static identifiers and recursive typeclasses to solve a host of problems related to schema definition, from JSON interchange to database design. I will show the approach Composite Records takes towards JSON schema definition and provide resources to investigate the rest, including Opaleye models and Swagger code generation.<br/><br/>Familiarity with, but not fluency in, both Lens and Aeson, especially Aeson Better Errors, will be expected for this talk.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/XA9Op0_TgoM/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/XA9Op0_TgoM/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/XA9Op0_TgoM/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/XA9Op0_TgoM/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT44M21S","dimension":"2d"},"statistics":{"viewCount":"146","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"1nkJGgHktUI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:31Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 1) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/1nkJGgHktUI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M29S","dimension":"2d"},"statistics":{"viewCount":"376","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"HNKvwTrp9zQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 2) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/HNKvwTrp9zQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT32M11S","dimension":"2d"},"statistics":{"viewCount":"151","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"p0Ecc9Kl3fE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:19Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/p0Ecc9Kl3fE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M13S","dimension":"2d"},"statistics":{"viewCount":"100","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dEVbS4pI3aY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dEVbS4pI3aY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H3M46S","dimension":"2d"},"statistics":{"viewCount":"91","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"NgL3FWsxn30","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:08Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 5) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/NgL3FWsxn30/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H46S","dimension":"2d"},"statistics":{"viewCount":"52","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"6KmqkC9puI0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:35:01Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Dana Scott &amp; Jeremy Siek - Theory &amp; Models of Lambda Calculus: Typed and Untyped (Part 6) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/tree/master/LC18-slides/LambdaCalculusWithScott%26Siek<br/><br/>INTRODUCTION: The formal systems that are nowadays called lambda-calculus and combinatory logic were both invented in the 1920s, and their aim was to describe the most basic properties of function-abstraction, application, and substitution in a very general setting. In lambda-calculus the concept of abstraction was taken as primitive, but in combinatory logic it was defined in terms of certain primitive operators called basic combinators.<br/><br/>Today they are used extensively in higher-order logic and computing. Seen in outline, the history splits into three main periods: first, several years of intensive and very fruitful study in the 1920s and &#39;30s; next, a middle period of nearly 30 years of relative quiet; then in the late 1960s an upsurge of activity stimulated by developments in higher-order function theory, by connections with programming languages, and by new technical discoveries. (Quotation from: Felice Cardone and J. Roger Hindley. &quot;History of lambda-calculus and combinatory logic.&quot; In: &quot;Handbook of the History of Logic, Vol. 5.&quot; Dov M. Gabbay and John Woods, editors, Elsevier Publishing Co., 2006, pp. 723-817.)<br/><br/>SKILLS: Attendees will learn the following skills in this workshop:<br/>- A brief review of history and of the main developers<br/>- How to use combinators and find their connection to lambda-calculus<br/>- How to define a mathematical model for lambda-calculus<br/>- How to introduce types into the model and make connections with category theory<br/>- How to understand how this connects with programming-language semantics<br/><br/>RELEVANCE: Many proposals for programming-language definitions and for their implementations depend on extensive formal theories employing lambda-calculus and combinators. Familiarity with an easy-to-define mathematical model can help developers keep to clear objectives and sound principles.<br/><br/>PITCH: The mathematical approach, using the powerset of the integers to model application and abstraction in lambda-calculus by using enumeration operators on the powerset, requires only very basic mathematics while giving the opportunity to introduce some ideas of topology, logic, abstract algebra and computability. The exposition of the workshop can be reviewed very gradually and does not depend on any heavy formalism. Appropriate written materials will be provided.<br/><br/>OUTLINE: The outline for this workshop will be as follows:<br/>- Session 1: Introduction to Combinators and Lambda Calculus<br/>- Session 2: Modeling by Enumeration Operators<br/>- Session 3: Applications of the Model to Semantics and Type Theory<br/><br/>CONCEPTS: This workshop proposes to cover the following concepts:<br/>- Rules for combinators<br/>- Variable elimination and function abstraction<br/>- Topologies on the powerset of the integers<br/>- Enumeration operators, fixed points and recursion<br/>- Examples of categories<br/>- Types as quotients of subspaces<br/>- Dependent types and polymorphic types<br/>- Propositions as types","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/6KmqkC9puI0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT33M17S","dimension":"2d"},"statistics":{"viewCount":"70","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"4WiNwODrYGI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:34:37Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"David Chambers - Programming Safely in an Uncertain World (Part 1) - λC 2018","description":"The world is an uncertain place. If we write programs that interact with the outside world, sometimes known as &quot;useful programs&quot;, we must acknowledge the possibility of failure. Every time we request a resource over the network, parse user input, or consume the output of another program, it&#39;s possible that the operation will not succeed. Imperative languages give us a few options in such cases: raising an exception, returning an error code, or succeeding with a bogus value such as NaN.<br/><br/>Algebraic data types such as Maybe, Either, and Future allow us to deal with uncertainty in a principled, unified manner: no more conditional logic; no more exceptions. Instead, we get simple building blocks that snap together. In conjunction with map and flat-map, algebraic data types allow us to collapse multiple sources of uncertainty into a single success or failure value. The decision about what to do in the case of an error is left to the caller, allowing the same error to be handled differently in different contexts.<br/><br/>JavaScript is not typically considered a functional language, but it&#39;s actually quite easy to define and use algebraic data types in JavaScript. This workshop will expose attendees to Maybe, Either, and Future in a JavaScript setting, and show how they can be used to write code that is dramatically simpler than the equivalent imperative code. The concepts learned during the workshop will be directly applicable to true functional languages such as Haskell.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/4WiNwODrYGI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/4WiNwODrYGI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/4WiNwODrYGI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/4WiNwODrYGI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT49M","dimension":"2d"},"statistics":{"viewCount":"235","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"N1LsbfHpMRI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:34:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"David Chambers - Programming Safely in an Uncertain World (Part 2) - λC 2018","description":"The world is an uncertain place. If we write programs that interact with the outside world, sometimes known as &quot;useful programs&quot;, we must acknowledge the possibility of failure. Every time we request a resource over the network, parse user input, or consume the output of another program, it&#39;s possible that the operation will not succeed. Imperative languages give us a few options in such cases: raising an exception, returning an error code, or succeeding with a bogus value such as NaN.<br/><br/>Algebraic data types such as Maybe, Either, and Future allow us to deal with uncertainty in a principled, unified manner: no more conditional logic; no more exceptions. Instead, we get simple building blocks that snap together. In conjunction with map and flat-map, algebraic data types allow us to collapse multiple sources of uncertainty into a single success or failure value. The decision about what to do in the case of an error is left to the caller, allowing the same error to be handled differently in different contexts.<br/><br/>JavaScript is not typically considered a functional language, but it&#39;s actually quite easy to define and use algebraic data types in JavaScript. This workshop will expose attendees to Maybe, Either, and Future in a JavaScript setting, and show how they can be used to write code that is dramatically simpler than the equivalent imperative code. The concepts learned during the workshop will be directly applicable to true functional languages such as Haskell.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/N1LsbfHpMRI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/N1LsbfHpMRI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/N1LsbfHpMRI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/N1LsbfHpMRI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M28S","dimension":"2d"},"statistics":{"viewCount":"65","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3OwijRsWO4w","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:34:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"David Chambers - Programming Safely in an Uncertain World (Part 3) - λC 2018","description":"The world is an uncertain place. If we write programs that interact with the outside world, sometimes known as &quot;useful programs&quot;, we must acknowledge the possibility of failure. Every time we request a resource over the network, parse user input, or consume the output of another program, it&#39;s possible that the operation will not succeed. Imperative languages give us a few options in such cases: raising an exception, returning an error code, or succeeding with a bogus value such as NaN.<br/><br/>Algebraic data types such as Maybe, Either, and Future allow us to deal with uncertainty in a principled, unified manner: no more conditional logic; no more exceptions. Instead, we get simple building blocks that snap together. In conjunction with map and flat-map, algebraic data types allow us to collapse multiple sources of uncertainty into a single success or failure value. The decision about what to do in the case of an error is left to the caller, allowing the same error to be handled differently in different contexts.<br/><br/>JavaScript is not typically considered a functional language, but it&#39;s actually quite easy to define and use algebraic data types in JavaScript. This workshop will expose attendees to Maybe, Either, and Future in a JavaScript setting, and show how they can be used to write code that is dramatically simpler than the equivalent imperative code. The concepts learned during the workshop will be directly applicable to true functional languages such as Haskell.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3OwijRsWO4w/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3OwijRsWO4w/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3OwijRsWO4w/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3OwijRsWO4w/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT35M37S","dimension":"2d"},"statistics":{"viewCount":"52","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"nbsEcyIuvNQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:34:16Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"David Zuch - That Warm and Fuzzy Feeling - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/nbsEcyIuvNQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/nbsEcyIuvNQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/nbsEcyIuvNQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/nbsEcyIuvNQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT35M55S","dimension":"2d"},"statistics":{"viewCount":"33","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"AqheIuSQjeM","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:33:46Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Diogo Biazus - Out of the Tarpit with Project M36 - λC 2018","description":"This talk will be a brief overview of Project M36, a relational algebra engine, as well as of the paper &quot;Out of the Tarpit&quot; that inspired the project. Project-M36 provides a clean interface using a dialect of TutorialD (the language proposed by Chris Date in &quot;The Third Manifesto&quot;). It also can be embedded in Haskell, and it actually allows the developer to model database fields using GADTs, eliminating the dreadful nulls. The cherry on top is the transaction graph, which expands the notion of rollback and commit to an almost git-like transaction manipulation.<br/><br/>The paper &quot;Out of the Tarpit&quot; by Ben Mosely and Peter Marks proposes a framework for software development to tame the huge complexity of modern systems. It analyzes the causes of complexity and proposes an approach based on the relational model and functional programming to deal with it. This paper has several prescriptions on how to isolate and state and control flow that are similar to currently used technologies. Project-M36 tries to fill every infrastructure need for the full implementation, using Haskell, of a functional relational system, as proposed in the paper.<br/><br/>The goal of the talk is to show that functional relational programming can be a viable alternative for the implementation of complex systems. Furthermore, some of its components (such as transactional graph and database GADTs) would definitely benefit all programmers, regardless of what sort of software architecture they ascribe to.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/AqheIuSQjeM/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/AqheIuSQjeM/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/AqheIuSQjeM/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/AqheIuSQjeM/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT52M34S","dimension":"2d"},"statistics":{"viewCount":"145","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"6c-5Ms8cOfA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:33:12Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Doug Beardsley &amp; Joel Burget - My Little Token (Part 1) - λC 2018","description":"My Little Token: Building Your Collectible Blockchain Smart Contract in Pact (Part 1)<br/><br/>In this workshop, participants will learn the fundamentals of developing smart contract blockchain applications using the language Pact, an open-source language developed by Kadena. Unlike other smart contract languages, Pact was designed for usability and offers features to improve the safety and security of smart contracts. This workshop will take you through developing a simple smart contract and explore Pacts formal verification system and its robust features of governance and multi-party escrow.<br/><br/>Pact is implemented in Haskell. This workshop will be led by the team that is helping develop and implement Pact.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/6c-5Ms8cOfA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/6c-5Ms8cOfA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/6c-5Ms8cOfA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/6c-5Ms8cOfA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M56S","dimension":"2d"},"statistics":{"viewCount":"46","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3WfGoXCvxxA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:32:44Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Doug Beardsley &amp; Joel Burget - My Little Token (Part 2) - λC 2018","description":"My Little Token: Building Your Collectible Blockchain Smart Contract in Pact (Part 2)<br/><br/>In this workshop, participants will learn the fundamentals of developing smart contract blockchain applications using the language Pact, an open-source language developed by Kadena. Unlike other smart contract languages, Pact was designed for usability and offers features to improve the safety and security of smart contracts. This workshop will take you through developing a simple smart contract and explore Pacts formal verification system and its robust features of governance and multi-party escrow.<br/><br/>Pact is implemented in Haskell. This workshop will be led by the team that is helping develop and implement Pact.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3WfGoXCvxxA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3WfGoXCvxxA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3WfGoXCvxxA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3WfGoXCvxxA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT36M51S","dimension":"2d"},"statistics":{"viewCount":"13","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"zJZnx4iXszs","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:32:18Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Edmund Noble - A Sense of Place:  What ReaderT Can Do in a Purely Functional World - λC 2018","description":"ReaderT is an oft-maligned member of the FP pantheon. It&#39;s often taught with configuration as the chief example all over the place, but in practice it&#39;s an uncommon way to use it and there are better alternatives. I&#39;ve found a new way to use it and exploited it with great results in a couple of Scala programs in production.<br/><br/>Exception stack traces in FP are useless for a lot of reasons. This prompted me to ask: what if the user could construct their own application and domain-specific trace, which they can include with exceptions? We&#39;ve all used at least a couple user-friendly applications that report something like, &quot;This error happened during X:&quot; followed by a message and stack trace.<br/><br/>In a similar vein, log messages include very little information on their origin, and it&#39;s difficult to filter them. Whole technology stacks are built around solving that problem at scale. If we knew &quot;where&quot; a log message came from, we&#39;d have an easier time of it, especially at smaller scales. Some loggers include source location, but as stated earlier, for stack traces that isn&#39;t as useful as you might think.<br/><br/>Profilers are similar. They&#39;re low-level tools that help with investigating issues on the method-level, but that&#39;s not always the right level of analysis; sometimes you don&#39;t know where a slowdown is, or what part of your application is calling into it. Sometimes, you just want to report coarsely-grained performance information.<br/><br/>These patterns are duplicated and hard-coded in applications. How can we make this location-awareness more like a library and not a design pattern? This workshop will show attendees how to use ReaderT in simple ways to construct and use traces with different values in different &quot;logical areas&quot; of a program, no stack traces needed.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/zJZnx4iXszs/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/zJZnx4iXszs/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/zJZnx4iXszs/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/zJZnx4iXszs/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M56S","dimension":"2d"},"statistics":{"viewCount":"296","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"tOmLv-ZWRgs","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:31:54Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Esther Wang - Typing the Y Combinator - λC 2018","description":"Theoretical languages such as the simply-typed lambda calculus and System F rose to fame by being the rough basis of many statically-typed functional programming languages, including Haskell. However, both of these languages are strongly normalizing, which means that well-typed programs are guaranteed to terminate. Yet we know that the untyped lambda calculus is Turing-complete, and permits terms such as the Y combinator that allow infinite recursion. How can we make a type system expressive enough to encode the type of a fixpoint operator?<br/><br/>Recursive types bridge the gap between a strongly-normalizing language and a Turing-complete language. In other words, they can be used to type the Y combinator. They also conveniently express the types of potentially infinite data structures, such as lists, trees, and streams. In this talk, I&#39;ll introduce recursive types and cover both the equi-recursive and the iso-recursive approaches to implementing them.<br/><br/>In addition to having various practical applications, recursive types can be generalized to mathematical concepts. They can be viewed as the least or greatest fixpoints of type equations, as inductively or coinductively-defined types, and as initial or terminal algebras. Exploring these interpretations will demonstrate the relevance of recursive types to the theory of programming languages.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/tOmLv-ZWRgs/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/tOmLv-ZWRgs/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/tOmLv-ZWRgs/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/tOmLv-ZWRgs/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT47M38S","dimension":"2d"},"statistics":{"viewCount":"123","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"G6D8Eoiz5pQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:31:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Fintan Halpenny - Read The Functional Manual: But First We Need to Write It - λC 2018","description":"Documentation can be critical to the use of a library. In the Haskell community, we are constantly relying on open source tools and libraries, and we also rely on the documentation to follow how the code works or how the tool is used. I have personally come across libraries where I was welcomed by a lack of documentation on its use. At times, the only documentation is a puzzle in the form of some category theory and a link to the research paper. At other times, the library maintainer could not find the time to write documentation. This can be frustrating to come across, because it means time wasted by digging into the library&#39;s innards. We want to make these Haskell libraries appeal to the masses and dispel the stigma of our libraries being poorly documented. To do this, I will present a discussion on the different categories of documentation starting from types and descriptions up to tutorials and blogs.<br/><br/>For each category I will examine a few aspects around the documentation. I will look at the relationship between documentation and author workflow, the help it gives newcomers and the usefulness of a library. I will take examples of each category of documentation and pick a library that does a good job demonstrating the power in each category and also find examples of where a library fails to meet the requirements of being helpful.Â I will also give my personal account on some of the libraries I contributed to such as &quot;esqueleto&quot; and &quot;proto-lens&quot;. I will go through how to make a pull request, with a live demonstration, and how users can contribute to documentation no matter how small or large. In reality, a lack of documentation is a bug that stops people from using your library so we should submit bug fixes!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/G6D8Eoiz5pQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/G6D8Eoiz5pQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/G6D8Eoiz5pQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/G6D8Eoiz5pQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT46M42S","dimension":"2d"},"statistics":{"viewCount":"75","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"2s7tRHFnThY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:30:46Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Forest Loren Toney III - The Road to Ocelot - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2s7tRHFnThY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2s7tRHFnThY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2s7tRHFnThY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2s7tRHFnThY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M38S","dimension":"2d"},"statistics":{"viewCount":"18","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"LhrLvcPI7z4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:30:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"François René Rideau - Binding Blockchains Together with Accountability - λC 2018","description":"I will present before you the holy grail of cryptocurrency: repudiable side-chains providing payments processing as fast as credit cards or any other arbitrary service without sacrificing the trustless security of account holders, provably bound with logical invariants to a main blockchain controlled by a distributed consensus.<br/><br/>I reached that grail by putting all the concepts back into place, both economic and (techno)logic: the respective roles of distributed chat (shared knowledge) vs. distributed consensus (common knowledge); the importance of accountability in maintaining good incentives, requiring actors to have skin in the game by posting bonds they&#39;ll lose if they misbehave; &quot;Exit&quot; (and &quot;Enter&quot;) being the mechanism to keep service providers honest, when &quot;Voice&quot; can only coordinate people whose interests are already aligned; distributed consensus as a court system that provides arbitration, not transactions; and non-publication being literally infinitely faster than publication.<br/><br/>Arbitration automatically resolves legal arguments where each interested party backs its claim by challenging the other in an interactive proof. Arbitrary logical invariants can thus be established using game semantics. The natural language in which to express contracts is therefore computability logic, far from the low-level virtual machines common in the industry or even the functional languages proposed to replace them. Well-designed contracts always provide one party a winning strategy, so losers better concede early rather than lose and cover all legal costs.<br/><br/>Linking two chains together requires encoding the evolving semantics of both chains in contracts. This construct is very fragile to the least discrepancy between the encoding and the actual chain implementation. Therefore this technology demands extraction of both blockchain implementation and contract evaluation language from a common logic specification, one that allows for reflective representation of the blockchain&#39;s own semantics.<br/><br/>Join me in the revolution of programming financial contracts with logic!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/LhrLvcPI7z4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/LhrLvcPI7z4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/LhrLvcPI7z4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/LhrLvcPI7z4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT51M47S","dimension":"2d"},"statistics":{"viewCount":"71","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"fH51qhI3hq0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:29:50Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"François René Rideau - First Class Implementations: Climbing up the Semantic Tower - λC 2018","description":"Software exists at multiple levels of abstraction, where each more concrete level is an implementation of the more abstract level above, in a semantic tower of compilers and/or interpreters. First-class implementations are a reflection protocol to navigate this tower at runtime: they enable changing the underlying implementation of a computation while it is running.<br/><br/>The key is a generalized notion of safe points that enables observing a computation at a higher-level than that at which it runs, and therefore enables climbing up the semantic tower, whereas at runtime most existing systems only ever allow you to go further down. The protocol I will describe was obtained by extracting the computational content of a formal specification for implementations and some of their properties. This approach reconciles two heretofore mutually exclusive fields: Semantics and Runtime Reflection.<br/><br/>My formalism makes some trivial use of category theory, though with partial rather than total functors. I&#39;ll leave it to experts to figure out the implications, though I&#39;ll suggest that implementation is the opposite of abstract interpretation, whereas natural transformations are opposite to code instrumentation.<br/><br/>I will explain how this theory opens a systematic approach to universally implementing a lot of currently prohibitively expensive ad hoc techniques, from code migration to time travel debugging to orthogonal persistence. I will discuss the price we pay to use first-class implementations as well as the benefits they bring, and I will explore new kinds of software architecture enabled by this new approach.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/fH51qhI3hq0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/fH51qhI3hq0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/fH51qhI3hq0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/fH51qhI3hq0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT51M31S","dimension":"2d"},"statistics":{"viewCount":"142","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"DltwrHwdxBY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:29:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Harold Carr - Let&#39;s Build a Blockchain - λC 2018","description":"Blockchain technology seems to be a killer app for functional programming languages, witnessed by companies such as IOHK, Adjoint.IO, Digital Assert, Kadena, and Tezos using Haskell and OCaml. But what is a blockchain? This talk will show the development of a simple blockchain in Haskell, elucidating the four main parts: 1) the tamper-evident append-only ledger; 2) the consensus system that decides what entries go into the ledger (and in what order); 3) the peer-to-peer network supporting consensus; 4) the &quot;smart contract&quot; system which interprets what the ledger entries mean (e.g., transfer a coin from Alice to Bob).<br/><br/>The concept of a ledger is built up from simple parts:<br/>- A single service receives entries on multiple concurrent channels. Each channel grabs a lock and places their entry into the ledger. This is the beginning of a ledger, but it is not-distributed, and it is open to DOS attacks by channels holding the lock too long.<br/>- In this step the channels add their entries to a pool. &quot;Miner&quot; threads pick entries from the pool and attempt to add them via compare-and-swap instructions. This avoids the DOS problem in #1 but it is still not-distributed.<br/>- Next the system becomes distributed by making the miners into separate nodes on a peer-to-peer network. Network communication will be done via UDP. Consensus among the peers will be achieved via a simple proof-of-work mechanism.<br/>- Up until this step, the entries on the ledger are just uninterpreted bytes. This step will introduce a simple smart contract language for interpreting those bytes. Initially, it will support creating named table entries and incrementing the value associated with the entry. Finally, it will show &quot;value&quot; (e.g., coins, property deeds) transfers between named tables entires (i.e., accounts), leveraging public-key cryptography.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/DltwrHwdxBY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/DltwrHwdxBY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/DltwrHwdxBY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/DltwrHwdxBY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M32S","dimension":"2d"},"statistics":{"viewCount":"114","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"z2uY-iKm4Bk","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:28:57Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ian Thomas - Breaking Out of the Fear Cycle - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/breaking-out-of-the-fear-cycle.pdf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/z2uY-iKm4Bk/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/z2uY-iKm4Bk/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/z2uY-iKm4Bk/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/z2uY-iKm4Bk/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M52S","dimension":"2d"},"statistics":{"viewCount":"72","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"yXUy-x62XCo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:28:30Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ian Thomas - From Zero to Live with Functional JavaScript Applications (Part 1) - λC 2018","description":"We are here, speakers and delegates alike, because we believe (or at least have a hunch) that developing software using functional programming principles will lead to better products, systems, and developer experiences. But isn&#39;t it surprising how often we find ourselves evangelising the benefits of FP only to find external factors and delivery pressures blocking our way?<br/><br/>Hear how we navigated the choppy waters of internal politics and non-functional constraints to help refactor our products into our vision of programming perfection. Leave with new ideas on how you can spread the passion for FP and identify opportunities to use your skills to drive value for your customers and business.<br/><br/>This talk is based on my personal experience with this situation while working for one of the few UK tech companies based in the north of England and valued over £1bn. Like many companies, we&#39;ve been through various phases of growth, all building on a monolithic OOP codebase:<br/>- The outsourced phase.<br/>- The early, in-house phase (we&#39;re small, agile and, rapidly delivering features).<br/>- The awkward scaling, misshapen, and unstable phase (the rough edges of early decisions are coming back to haunt us).<br/>- The fear cycle phase (small changes cause bugs and outages so the scope of changes decreases, leading to more technical debt, bugs, and slower delivery).<br/><br/>However, we&#39;ve seen the benefits of using functional programming. Multi-million-pound opportunities have been realized through composable, functional JavaScript. Our bug count has decreased and speed to market has improved. Yet, despite this success, we&#39;re still fighting to stop people using mutable state, leaky abstractions (&quot;classitis&quot;&quot;), and code so full of side effects you can&#39;t write a test without first having to mock the majority of the application. Scaling teams and the software they produce is hard!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/yXUy-x62XCo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/yXUy-x62XCo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/yXUy-x62XCo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/yXUy-x62XCo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT45M6S","dimension":"2d"},"statistics":{"viewCount":"63","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"bWRXOJYzJZ0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:27:55Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ian Thomas - From Zero to Live with Functional JavaScript Applications (Part 2) - λC 2018","description":"We are here, speakers and delegates alike, because we believe (or at least have a hunch) that developing software using functional programming principles will lead to better products, systems, and developer experiences. But isn&#39;t it surprising how often we find ourselves evangelising the benefits of FP only to find external factors and delivery pressures blocking our way?<br/><br/>Hear how we navigated the choppy waters of internal politics and non-functional constraints to help refactor our products into our vision of programming perfection. Leave with new ideas on how you can spread the passion for FP and identify opportunities to use your skills to drive value for your customers and business.<br/><br/>This talk is based on my personal experience with this situation while working for one of the few UK tech companies based in the north of England and valued over £1bn. Like many companies, we&#39;ve been through various phases of growth, all building on a monolithic OOP codebase:<br/>- The outsourced phase.<br/>- The early, in-house phase (we&#39;re small, agile and, rapidly delivering features).<br/>- The awkward scaling, misshapen, and unstable phase (the rough edges of early decisions are coming back to haunt us).<br/>- The fear cycle phase (small changes cause bugs and outages so the scope of changes decreases, leading to more technical debt, bugs, and slower delivery).<br/><br/>However, we&#39;ve seen the benefits of using functional programming. Multi-million-pound opportunities have been realized through composable, functional JavaScript. Our bug count has decreased and speed to market has improved. Yet, despite this success, we&#39;re still fighting to stop people using mutable state, leaky abstractions (&quot;classitis&quot;&quot;), and code so full of side effects you can&#39;t write a test without first having to mock the majority of the application. Scaling teams and the software they produce is hard!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/bWRXOJYzJZ0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/bWRXOJYzJZ0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/bWRXOJYzJZ0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/bWRXOJYzJZ0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M10S","dimension":"2d"},"statistics":{"viewCount":"31","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"u1T9zjsHGJM","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:27:22Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ivan Gromakovskii - Developing Cardano Cryptocurrency in Haskell - λC 2018","description":"Haskell is a great programming language, but unfortunately it&#39;s not quite popular for solving real business problems. Despite the increasing popularity of functional programming in general and Haskell in particular, languages such as Java, Python and C++ are still more popular.<br/><br/>Cardano is one of the biggest cryptocurrencies in the world by market cap which is written in Haskell from scratch. In this talk, Cardano will be presented from the technical perspective. This talk is intended to demonstrate the suitability of Haskell for solving real-world business problems specifically for blockchain development. It will cover the advantages of using Haskell and will provide real-life examples from the author&#39;s experience working on Cardano. It will also mention difficulties which were encountered.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/u1T9zjsHGJM/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/u1T9zjsHGJM/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/u1T9zjsHGJM/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/u1T9zjsHGJM/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT46M46S","dimension":"2d"},"statistics":{"viewCount":"180","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"-Na2i8MbXbI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T21:26:57Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Izaak Meckler - Snarky: Algebraic effects in the Coda cryptocurrency - λC 2018","description":"We present Snarky, an OCaml embedded DSL for writing computations certified by zk-SNARKs. A certified computation is a value accompanied by a certificate proving that it was computed correctly.<br/><br/>SNARK-certified computation has applications in protecting user privacy and delegating computation to untrustworthy parties (particularly in blockchain settings). However, using them has thus far required the tedious and error-prone process of constructing constraint systems directly, akin to writing assembly by hand. Snarky makes it easy to write typed, high-level code that can be compiled into a constraint system to produce a zk-SNARK.<br/><br/>Snarky is being used by O(1) Labs in the development of Coda, a new cryptocurrency protocol that uses SNARKs to compress the entire transaction history into a few-hundred-byte proof. This talk will discuss the programming-language-theoretic ideas underlying Snarky as well as its application in Coda.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-Na2i8MbXbI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/-Na2i8MbXbI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/-Na2i8MbXbI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/-Na2i8MbXbI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M28S","dimension":"2d"},"statistics":{"viewCount":"275","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Yf1ryR9-cho","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:55:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"J Haigh - Seriously, The Haskell Type Checker is Your Friend - λC 2018","description":"An essential skill for becoming productive in Haskell is identifying and resolving error messages in GHC. Error messages can be cryptic and hard to overcome when you are a beginner. Often, it&#39;s helpful when you have someone walk you through identifying what these error messages mean the first time you encounter them. Some GHC errors will lead beginners astray and they will end up trying to solve a different problem, because they have misinterpreted what the error is pointing to as the issue in their code. During this presentation, I will cover GHC type errors by showing code examples and work through, step by step, how to fix these errors. I will have code snippets in the slides to highlight problems. Additionally, I will do some live coding to show which compiler errors we get in GHCi. Code examples will iterate through examples of common beginner mistakes. The presentation will show how a beginner&#39;s errors can compound and lead them to misinterpret the problem. It will show attendees these errors are difficult to figure out, but they also have all the tools to debug their code mistakes. With a little practice, they&#39;ll be explaining errors to new beginners, themselves.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Yf1ryR9-cho/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Yf1ryR9-cho/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Yf1ryR9-cho/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Yf1ryR9-cho/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT31M50S","dimension":"2d"},"statistics":{"viewCount":"162","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"msQiLyExM3w","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:54:36Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jake Keuhlen - Extensibly Free Arrows - λC 2018","description":"In this talk, we&#39;ll break open a few critical ideas: extensible data types, free, and arrows. Then, we&#39;ll combine all of them to create the extensibly free arrow. Free arrows allow for extreme flexibility with effectful programming and their extensible nature allows for programs that are easier to extend, augment. and reuse.<br/><br/>Extensibly: extensible types are those that can be extended without changing the original definition. In Haskell, ADTs are the perfect example of a closed sum type. It is a &quot;closed&quot; type, because you must change the actual definition of the type in the code in order to extend it. Extensible (or open) types are those like type classes, to which new instances can be added at any time without changing the fundamental definitions. The extensible-sp package allows us to create open sum and product types that naturally encapsulate both effects and errors within a program.<br/><br/>Free: free is a functional programming concept that allows for abstraction over effect types. Free programs are simple data structures that defer effectful logic. For example, a certain function may use printing in a free manner. This function can be used in various contexts, picking between multiple options for what &quot;print&quot; means: to the screen, to a log file, or across a websocket.<br/><br/>Arrow: arrows are a generalization of monads and are a good fit for programs with logical, sequential flows. Arrows provide a useful structure for free implementations, and a simple syntax for combining operations in sequential flows. For non-sequential actions, Arrow&#39;s `proc` syntax allows for a flexibility similar to that of a do-block.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/msQiLyExM3w/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/msQiLyExM3w/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/msQiLyExM3w/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/msQiLyExM3w/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT47M6S","dimension":"2d"},"statistics":{"viewCount":"149","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"P1dmHKJ2vak","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:54:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jarek Ratajski - Beauty and the Beast: Haskell for JVM - λC 2018","description":"After 20 years of evolution, the Java Virtual Machine became a real masterpiece of engineering and can easily outperform static compilers in many cases. There are,the however, lots of issues arising when someone tries to use JVM for functional languages. The Clojure and Scala compiler creators had to fight with JVM types, the lack of tail recursion, and other problems. It was particularly hard to create an efficient Haskell implementation for the JVM.<br/><br/>The developers of Eta tried it once again in a different way. We will analyze how it works on a sample system, where the business logic is written in Haskell and middleware components and libraries in Java. We will try to analyze when it makes sense and it compares to the pure Java/Haskell implementation in terms of performance and code quality.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/P1dmHKJ2vak/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/P1dmHKJ2vak/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/P1dmHKJ2vak/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/P1dmHKJ2vak/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M42S","dimension":"2d"},"statistics":{"viewCount":"290","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"yiErJnOf-uA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:53:39Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jason Litton - Free Your Monads and the Rest Will Follow - λC 2018","description":"Our primary business product has a strange mix of rules and flexibility. We generate reports that are generally the same in data, but have a different flavor of presentation depending on the business that we are generating them for. Last year, we began replacing the legacy workflow engine for generating our most important product with a new code base built around the free monad. It gave us a new workflow engine with strong rules around how things get done but allowing flexibility in the process in order to meet different detailed needs for our customers. The change reduced the customer onboarding time from six months or more to a couple of weeks and reduced production code lines by 80%.<br/><br/>In this talk, I will walk you through:<br/>- Our migration process.<br/>- Why we chose free monads.<br/>- How we built around the concept.<br/>- What our successes and failures were.<br/>- How you can think about free monads in your production environment.<br/><br/>I will also show you the considerations we took to make sure ANY of our developers, even those not familiar with Scala or Category Theory could jump into the project and contribute. This talk is suited to practical development and is appropriate for all levels of developers who want to learn about Free Monads in the wild.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/yiErJnOf-uA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/yiErJnOf-uA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/yiErJnOf-uA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/yiErJnOf-uA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT44M59S","dimension":"2d"},"statistics":{"viewCount":"139","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"vU3caZPtT2I","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:53:10Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jeremy G. Siek - Crash Course on Notation in Programming Language Theory (Part 1) - λC 2018","description":"If you have ever tried to read a paper about programming languages from an ACM conference such as Principles of Programming Languages (POPL) or the International Conference on Functional Programming (ICFP), then you&#39;re familiar with the dizzying amount of strange notation that is used in those papers. This workshop is a crash course on the most common notation used in programming language theory and the underlying ideas. The workshop will assume that the attendees are experienced programmers but not mathematicians or PL theorists. We will start with the most basic definitions and build up from there. The workshop will cover how to work with sets, tuples, relations, and inductive definitions. It will then move on to specifying language syntax with grammars. The high-point of the workshop is an introduction to operational semantics. The workshop will conclude with a introduction to type systems and the notion of a type safe programming language.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/vU3caZPtT2I/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/vU3caZPtT2I/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/vU3caZPtT2I/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/vU3caZPtT2I/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M35S","dimension":"2d"},"statistics":{"viewCount":"669","likeCount":"13","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"MhuK_aepu1Y","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:53:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jeremy G. Siek - Crash Course on Notation in Programming Language Theory (Part 2) - λC 2018","description":"If you have ever tried to read a paper about programming languages from an ACM conference such as Principles of Programming Languages (POPL) or the International Conference on Functional Programming (ICFP), then you&#39;re familiar with the dizzying amount of strange notation that is used in those papers. This workshop is a crash course on the most common notation used in programming language theory and the underlying ideas. The workshop will assume that the attendees are experienced programmers but not mathematicians or PL theorists. We will start with the most basic definitions and build up from there. The workshop will cover how to work with sets, tuples, relations, and inductive definitions. It will then move on to specifying language syntax with grammars. The high-point of the workshop is an introduction to operational semantics. The workshop will conclude with a introduction to type systems and the notion of a type safe programming language.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/MhuK_aepu1Y/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/MhuK_aepu1Y/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/MhuK_aepu1Y/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/MhuK_aepu1Y/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H3M10S","dimension":"2d"},"statistics":{"viewCount":"249","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"D5DsRzijK0k","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:52:30Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jim Duey - Typing a LISP - λC 2018","description":"Many practitioners of functional programming consider static typing a prerequisite. At the same time, there&#39;s a large population of programmers who prefer the flexibility of dynamic typing.<br/><br/>This talk describes a Lisp dialect with a type system intended to give as many benefits of static typing as possible while preserving the flexibility of dynamic typing. This type system is gradual, algebraic and dependent. A brief definition of each of these concepts will be illustrated with code showing how each improves the software creation process.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/D5DsRzijK0k/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/D5DsRzijK0k/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/D5DsRzijK0k/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/D5DsRzijK0k/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M10S","dimension":"2d"},"statistics":{"viewCount":"115","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Tq8VVw3li4Q","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:52:04Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jimmy Torre - Learning Propositional Logic with Logic Programming - λC 2018","description":"Whether alongside a professor, pupil, or peer, one often learns best in the company of another. As programmers encountering new subject matter, we have a fourth option: writing programs to assist our investigation and knowledge acquisition. Using propositional logic (aka sentential logic or SL) as a motivating example, we will demonstrate how functional programming in particular can buttress auto-didacticism.<br/><br/>Our programs will begin as pupils: the grammar of SL statements will be translated, using the meta-programming capabilities of Scheme, into a Domain Specific Language within miniKanren, itself a Prolog-like logic programming DSL embedded in Scheme.<br/><br/>A simple, automated theorem prover next becomes our peer and study partner. Anecdotes from its development will illustrate certain ways in which one&#39;s understanding of a subject is refined during the journey from &quot;on paper&quot; to &quot;in code.&quot; Automating the deduction of SL equivalences forces explicit consideration of the logic&#39;s principles and the ergonomics of deductive proofs.<br/><br/>Finally, we will work through several proofs in SL, using our newly coded professor to check our work. A REPL-driven style, iteratively aggregating theorems as they are proven, allows us to keep fine-grained track of our progress towards increasingly powerful results.<br/><br/>Throughout, the transparency with which code can complement conventional study techniques will be emphasized.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Tq8VVw3li4Q/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Tq8VVw3li4Q/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Tq8VVw3li4Q/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Tq8VVw3li4Q/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H48S","dimension":"2d"},"statistics":{"viewCount":"86","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"S84vOaTpR18","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:51:30Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joe Kachmar - Input Validation in PureScript: Simpler, Safer, and Stronger (Part 1) - λC 2018","description":"I&#39;ve often found myself asking the following questions while writing software: how can I write functions that take untyped, unvalidated input and return something that other functions can safely use, and how can these functions be written such that common validation patterns are reusable in different scenarios?<br/><br/>With a little research and experimentation, I&#39;ve come to realize that strong, statically typed, functional programming provides a compelling answer to these questions.<br/><br/>My workshop will show how basic algebraic data types help you clearly, and reliably, represent data before and after validation. These types will be used to build basic validation functions that can be composed with each other using the Applicative typeclass to create validation pipelines that are as simple or as complex as your application requires. Finally, we&#39;ll cover how PureScript&#39;s row polymorphism allows us to create extremely modular validation functions, while retaining the safety of a strong, static type system.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/S84vOaTpR18/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/S84vOaTpR18/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/S84vOaTpR18/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/S84vOaTpR18/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT42M48S","dimension":"2d"},"statistics":{"viewCount":"226","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Kz4QgBW3P9k","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:51:21Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joe Kachmar - Input Validation in PureScript: Simpler, Safer, and Stronger (Part 2) - λC 2018","description":"I&#39;ve often found myself asking the following questions while writing software: how can I write functions that take untyped, unvalidated input and return something that other functions can safely use, and how can these functions be written such that common validation patterns are reusable in different scenarios?","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Kz4QgBW3P9k/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Kz4QgBW3P9k/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Kz4QgBW3P9k/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Kz4QgBW3P9k/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT36M31S","dimension":"2d"},"statistics":{"viewCount":"56","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"w77Nj4SFH2M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:50:47Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joel Burget - Authoring and Formal Verification of Smart Contracts in Pact - λC 2018","description":"In this talk we&#39;ll discuss the design and implementation of a smart contract property verification tool for Pact. Pact is lisp-based, statically typed, non-Turing-complete, and has a limited set of primitives. We leverage these (lack of) features to build a system capable of proving many properties of contracts via the Z3 SMT solver. We&#39;ll also give examples of real bugs caught by the system.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/w77Nj4SFH2M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/w77Nj4SFH2M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/w77Nj4SFH2M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/w77Nj4SFH2M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT36M36S","dimension":"2d"},"statistics":{"viewCount":"41","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"L8AEj6IRNEE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:48:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"John A  De Goes - Blazing Fast, Pure Effects without Monads - λC 2018","description":"Effect monads like IO are the way functional programmers interact with the real world. Yet, monadic effects in programming languages like Scala often perform poorly compared to their Haskell counterparts as much as 10x slower in some benchmarks. In this presentation, John A. De Goes, author of the Scalaz 8 effect system, dredges up an old paper to cast new light on the question of how to model effects, and comes to the surprising conclusion that in Scala, monads may not be the fastest way to model purely functional effects. Join John as he shows a new model of effects that offers performance improvements without sacrificing the wonderful purity that functional programmers rely on to reason about their software.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/L8AEj6IRNEE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/L8AEj6IRNEE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/L8AEj6IRNEE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/L8AEj6IRNEE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M40S","dimension":"2d"},"statistics":{"viewCount":"3613","likeCount":"85","dislikeCount":"3","favoriteCount":"0","commentCount":null}},{"id":"0Phf8O_xcMo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:47:49Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"John Azariah - Diving Into Q# - λC 2018","description":"Many experts in the field agree that quantum computing is finally within the realm of realization. But quantum computation uses primitives and constructs that are very different from classical computing. The Q# language, the subject of this talk, introduces some principles and unique challenges of quantum computing. We will discuss the approach that resulted in the design of a new, purpose-built, domain-specific language. A deep knowledge of quantum computing is not required for this talk, as the talk itself is focused on language design for the specific domain.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0Phf8O_xcMo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/0Phf8O_xcMo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/0Phf8O_xcMo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/0Phf8O_xcMo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M19S","dimension":"2d"},"statistics":{"viewCount":"51","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3O1t0w1-L70","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:47:18Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jonathan Curran - Interactive Testing with Flare and Halogen - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3O1t0w1-L70/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3O1t0w1-L70/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3O1t0w1-L70/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3O1t0w1-L70/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT11M39S","dimension":"2d"},"statistics":{"viewCount":"17","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"bt130Z7UNPE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:50Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jonathan Curran - JavaScript to Purescript  A Migration Story - λC 2018","description":"Maintaining a large, interactive JavaScript web application is a challenging task given the dynamic nature of the language and the relatively few shared common abstractions supported by various libraries and frameworks in its ecosystem. Having outgrown JavaScript, Angular, and Redux-Sagas, we looked in our company to PureScript and Halogen in the hope of being able to easily maintain and steadily grow our application while being able to reason about its behavior with relative ease.<br/><br/>During this session, we will explore what an iterative migration from a JavasScript-heavy application to a PureScript application looks like. We will explore various pain points experienced with the JavaScript ecosystem during the development of our application and show how we addressed these issues with the introduction of PureScript, Halogen, and a few supporting libraries. Participants will learn how we embedded PureScript in our existing web application, how we performed data validation and authentication, and how bi-directional messaging between UI components can be used to perform complex tasks. Finally, we will demonstrate a few testing strategies.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/bt130Z7UNPE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/bt130Z7UNPE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/bt130Z7UNPE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/bt130Z7UNPE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H4M21S","dimension":"2d"},"statistics":{"viewCount":"352","likeCount":"7","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"V56x7dPfoJw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 1) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/V56x7dPfoJw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/V56x7dPfoJw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/V56x7dPfoJw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/V56x7dPfoJw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M11S","dimension":"2d"},"statistics":{"viewCount":"275","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"TXImOmWnmxw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:19Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 2) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/TXImOmWnmxw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/TXImOmWnmxw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/TXImOmWnmxw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/TXImOmWnmxw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M19S","dimension":"2d"},"statistics":{"viewCount":"32","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"erRTnKdiNRo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 3) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/erRTnKdiNRo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/erRTnKdiNRo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/erRTnKdiNRo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/erRTnKdiNRo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M49S","dimension":"2d"},"statistics":{"viewCount":"21","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"obtSvdA6M8o","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:08Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 4) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/obtSvdA6M8o/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/obtSvdA6M8o/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/obtSvdA6M8o/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/obtSvdA6M8o/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H5M1S","dimension":"2d"},"statistics":{"viewCount":"16","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"2Ixpz3oFwDQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:46:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 5) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2Ixpz3oFwDQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2Ixpz3oFwDQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2Ixpz3oFwDQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2Ixpz3oFwDQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M22S","dimension":"2d"},"statistics":{"viewCount":"8","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dOpPoY7kNxA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:45:51Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - Modern, Functional Cryptography (Part 6) - λC 2018","description":"This workshop proposal lays out a mathematics-heavy, developer introduction to modern cryptography in a functional programming context.<br/><br/>I plan to cover the following topics, often covered by university cryptography courses:<br/><br/>- A quick introduction to classical cryptography as a pathway to the goals and general properties of ciphers, as well as the common attack vectors used for basic cryptanalysis.<br/>- Introduction to number theory and abstract algebra.<br/>- Symmetric cryptography: Block and stream ciphers, modes of operation, key management.<br/>- Asymmetric cryptography: The Diffie-Hellman problem, Elgamal PKCS, RSA, and code examples and implementations.<br/>- Pseudorandom functions (PRF) and pseudorandom generators (PRGs)<br/>- A section on combinatorics, probability, and information theory.<br/>- Introduction to hashing, message authentication, and digital signatures. Applications with cryptocurrencies.<br/>- Elliptic curve cryptography. Applications in ECDSA and ECEIS.<br/>- Time-permitting: Lattice based crypto and advanced topics in cryptography.<br/><br/>Throughout the sections, we will develop a cryptographic library based on laws and formulated with typeclasses, each of which will play a part in developing a secure web application backend. Emphasis, in particular, will be placed on understanding cryptographic constructs both mathematically and from an application perspective. This includes common web application topics like deploying with TLS, tokens vs. cookies, JWTs explained, sessions, and common attacks. Even though we will begin from first principles, real-world emphasis will be put on using up-to-date cryptographic constructs, protocols, and avoiding outdated pitfalls, as well as what to look for in cryptographic libraries.<br/><br/>This workshop aims to empower developers not only to build your generic authenticated backend, but to go further into understanding the applications and uses of cryptographic protocols within a functional, lawful context. I aim to bring up cryptography and security from the afterthought that gets you Equifax&#39;d, to a tangible tool in your developer and company arsenal.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dOpPoY7kNxA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dOpPoY7kNxA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dOpPoY7kNxA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dOpPoY7kNxA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M45S","dimension":"2d"},"statistics":{"viewCount":"19","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"FxxcY_Irv9M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:45:45Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Jose Cardona - ScalaZ and Cryptography - λC 2018","description":"miniconf","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/FxxcY_Irv9M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/FxxcY_Irv9M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/FxxcY_Irv9M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/FxxcY_Irv9M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT28M4S","dimension":"2d"},"statistics":{"viewCount":"51","likeCount":"3","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"r67_eMP2HoY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:45:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joseph Abrahamson - The Shape of Shapeless (Part 1) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/the_shape_of_shapeless_slides.pdf<br/><br/>Shapeless is a daunting Scala library, and while it is tempting and often most practical to leave it to the type astronauts, anyone with a solid Scala foundation can start to learn the ideas there and profit both in their ability to write sophisticated, high-order code but also to understand the strengths and limitations of the Scala type system and inferencer.<br/><br/>This advanced session breaks down the why, what, and how of some of the more fundamental Shapeless concepts and gives attendees a chance to play with these techniques and execute on common patterns while learning how to identify and avoid common gotchas. Walking out, you should feel comfortable defining a generic implementation of a simple typeclass and be able to understand when and why Shapeless is used in lieu of macros.<br/><br/>In coming to understand Shapeless, you will undoubtedly begin to recognize many patterns exploited in higher-order functional programming techniques, such as applicatives and typeclasses being carried out in a very generic fashion. It will also provide enough practice with higher-kinded types that you can turn to them confidently to solve a number of common problems.<br/><br/>Shapeless is a deep library, and a two hour session cannot hope to plumb its depths, but after attending you should feel confident that you know what Shapeless is and what problems it is solving, confident that you can recognize when they come up and make or understand tradeoffs about whether these techniques are worth it. Walking out, you should understand the shape of Shapeless.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/r67_eMP2HoY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/r67_eMP2HoY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/r67_eMP2HoY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/r67_eMP2HoY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M11S","dimension":"2d"},"statistics":{"viewCount":"186","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"k5eHi2E9M6M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:45:06Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joseph Abrahamson - The Shape of Shapeless (Part 2) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/the_shape_of_shapeless_slides.pdf<br/><br/>Shapeless is a daunting Scala library, and while it is tempting and often most practical to leave it to the type astronauts, anyone with a solid Scala foundation can start to learn the ideas there and profit both in their ability to write sophisticated, high-order code but also to understand the strengths and limitations of the Scala type system and inferencer.<br/><br/>This advanced session breaks down the why, what, and how of some of the more fundamental Shapeless concepts and gives attendees a chance to play with these techniques and execute on common patterns while learning how to identify and avoid common gotchas. Walking out, you should feel comfortable defining a generic implementation of a simple typeclass and be able to understand when and why Shapeless is used in lieu of macros.<br/><br/>In coming to understand Shapeless, you will undoubtedly begin to recognize many patterns exploited in higher-order functional programming techniques, such as applicatives and typeclasses being carried out in a very generic fashion. It will also provide enough practice with higher-kinded types that you can turn to them confidently to solve a number of common problems.<br/><br/>Shapeless is a deep library, and a two hour session cannot hope to plumb its depths, but after attending you should feel confident that you know what Shapeless is and what problems it is solving, confident that you can recognize when they come up and make or understand tradeoffs about whether these techniques are worth it. Walking out, you should understand the shape of Shapeless.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/k5eHi2E9M6M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/k5eHi2E9M6M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/k5eHi2E9M6M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/k5eHi2E9M6M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M55S","dimension":"2d"},"statistics":{"viewCount":"62","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"9gkWLA6yxlY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:44:39Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Joseph Cieslik - Simple Elixir MapReduce - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/9gkWLA6yxlY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/9gkWLA6yxlY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/9gkWLA6yxlY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/9gkWLA6yxlY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT24M16S","dimension":"2d"},"statistics":{"viewCount":"22","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"boK0WcVenyk","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:44:02Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Juan Pablo Santos - Using Corecursion Schemes - λC 2018","description":"The workshop has a very concrete goal: attendees will see how to use an apomorphism practically.<br/><br/>Attendees are expected to have some experience in the programming language chosen for the workshop. The workshop can be done either with Kmett&#39;s recursion-schemes or matryoshka in Scala. Those who know Scala will also need to know a little about functional programming with scalaz or cats.<br/><br/>Despite the scary names of the terminology here, we will approach the concepts very practically. For example, we will use theÂ CofreeÂ comonad to tag nodes in a tree.<br/><br/>Intro<br/>- When to use recursion-schemes.<br/>- The recursion-schemes/matryoshka packages.<br/>- Quick intro to type families.<br/>- The `Base typeclass/Corecursive trait.<br/>- Corecursive typeclass.<br/>- Quick intro to fixpoints.<br/>- F-(co)algebras. <br/>- Some type synonyms to keep in mind (if using matryoshka).<br/>- A quick review of folds.<br/><br/>Corecursion schemes<br/>- `ana` and what it is<br/>- Recursive structures as the seed of the anamorphism.<br/>- Uses and limitations. Brief examples (tagging specific nodes with a given tag).<br/>- Introduction to Cofree.<br/>- How `apo` overcomes some of the limitations of `ana`.<br/><br/>Write code for `apo` to tag nodes nested under a specific node using `apo`, `cata`, and Cofree.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/boK0WcVenyk/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/boK0WcVenyk/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/boK0WcVenyk/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/boK0WcVenyk/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT2H16S","dimension":"2d"},"statistics":{"viewCount":"83","likeCount":"3","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"1BpnQcJTzNA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:43:31Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Justin LeBlanc - Hoon and You: A Functional Programming Perspective - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/hoon-talk-slides.pdf <br/><br/>Hoon is a functional programming language that is neither based on lambda calculus nor category theory. How is this possible? Does it involve witchcraft?<br/><br/>This talk will feature a discussion of Hoon&#39;s origins as a &quot;minimally viable&quot;\u009d programming language for developing an OS and network stack. It will cover Hoon&#39;s unique syntax which is not nearly as terrifying as it seems at first and its data structures.<br/><br/>In lieu of lambda calculus and category theory, this talk will discuss how Hoon code works and how a functional programming language can achieve a somewhat &quot;procedural&quot; feel without sacrificing the advantages of FP.<br/><br/>Design decisions in programming languages are ultimately an exercise in tradeoffs. The type system in Hoon is a good example of this. This talk will discuss the problems solved by typing, how they work in Hoon, and a comparison with types in Haskell and Scala.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/1BpnQcJTzNA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/1BpnQcJTzNA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/1BpnQcJTzNA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/1BpnQcJTzNA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT49M9S","dimension":"2d"},"statistics":{"viewCount":"230","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"p84OIPL3t7M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:43:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Keagan McClelland - Haskelling Bitcoin for Great Good - λC 2018","description":"In 2018, it&#39;s hard to go a few days without hearing about Bitcoin or the ecosystem that is &quot;blockchain technology.&quot; The proponents believe that the technology of permissionless, open blockchains is going to radically transform the way we interact with one another. On the flip side, we hear about all of the high profile hacks and bugs that have either resulted in stolen or frozen funds.<br/><br/>In a world where software is executed on machines that the developer does not control, programming must be done without the luxury of ad-hoc hot fixes. Fortunately, unlike other high assurance engineering professions, blockchain nodes don&#39;t have to run on specialized hardware in such a way that demands extreme performance, and as such we can take immense advantage of advances in language design without significant impact to the final product. Writing these sorts of projects in strong, statically-typed languages with denotational semantics can give us significantly more confidence in their correctness before we deploy them, at far lower cost. As a result, functional programming is poised to be a much more favored methodology for blockchain development and peer-to-peer applications in the future.<br/><br/>In this talk we will examine a basic Bitcoin-style blockchain implementation in Haskell with a focus on the more &quot;real-world&quot; aspects of substantial projects that often get overlooked in various tutorials. This will serve as a unique introduction into an emerging industry, including both the basics of blockchain and an exposition of how the FP developer is uniquely suited to building safer peer-to-peer applications.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/p84OIPL3t7M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/p84OIPL3t7M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/p84OIPL3t7M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/p84OIPL3t7M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M57S","dimension":"2d"},"statistics":{"viewCount":"35","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Jo5IvdcBOIY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:42:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Lander Lopez - Set Theoretic Algebraic Constructive Calculus - λC 2018","description":"The audience is invited to revisit the foundations of FP languages through the unorthodox interpretation in Stacc, &quot;Set Theoretic Algebraic Constructive Calculus.&quot;<br/><br/>Stacc is a novel type theory calculus rooted in set theory and constructive logic. It will be open sourced this year as the core language for a new, dependently-typed language on the JVM. This yet-to-be-named language will explore the algebraic FP space.<br/><br/>The calculus embraces the idea of &quot;propositions as types,&quot; and the programs in Stacc are sets of predicates. Subtyping occurs naturally in the calculus while avoiding the soundness problems found in other hybrid FP and OO attempts like Scala.<br/><br/>Pedagogically, it fills a gap where people are exposed to pure or simply typed lambda calculus and then to a final FP language. Understanding the mappings between the two levels of abstraction usually requires advanced type theory knowledge. Stacc sits in the middle, with a richer meta-theory than the lambda calculus, shrinking that abstraction gap.<br/><br/>Another virtue of Stacc is the unification of different constructs. For example, type refinement, subtyping, or function application are all encoded as union of sets of predicates with simple semantics.<br/><br/>The calculus resolver has a REPL to code and test the proofs, aka programs. The material in this talk will include live proofing in the REPL, along with supporting Venn diagrams. The syntax is directly understandable at an undergraduate mathematics level, so no new notation will need to be introduced.<br/><br/>The talk will show how the calculus supports dependent types, higher kindedness, subtyping, and variance using examples from Peano numbers and lists.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Jo5IvdcBOIY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Jo5IvdcBOIY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Jo5IvdcBOIY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Jo5IvdcBOIY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT55M15S","dimension":"2d"},"statistics":{"viewCount":"72","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"cVShQbMfpZk","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:42:04Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Markus Hauck - Free All The Things - λC 2018","description":"Have you ever asked yourself why we only free monads? Turns out there are a lot of other structures that want to be liberated from the constraints of their existence! In this talk, we will investigate what other poor (algebraic) structures we can free from the dirty hands of imperative programmers. Our journey starts with the well-known free monads, but after that we will have a look at all the other interesting structures that can be freed and of course we will also look at what we can do with them.<br/><br/>Knowledge of typeclasses like Monad, Applicative, and Functor is beneficial but not required.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/cVShQbMfpZk/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/cVShQbMfpZk/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/cVShQbMfpZk/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/cVShQbMfpZk/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT33M41S","dimension":"2d"},"statistics":{"viewCount":"65","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"v4StENGDWZg","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:41:31Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Markus Hauck - How This Presentation Was Made - λC 2018","description":"Let&#39;s face it, building a presentation is a pain in the neck. If you include graphics that are themselves generated, you have to manually make sure that both your graphics as well as your presentation are rebuilt to have everything up to date.<br/><br/>And what about the code? It should at least compile, so that you can avoid silly typos, but how can you ensure that? Most of the time, it is typed once but later changed, and then errors may be introduced.<br/><br/>In this talk, I will show you how to build a complex presentation from many moving parts that are themselves generated. More specifically, we will use the Haskell library Shake to write build systems as well as other libraries to build a complete presentation from the ground up. We will handle typed configuration, custom build systems, functional package managers, and more!<br/><br/>And even better, our presentation will build in parallel and only do the minimal amount of work necessary after our changes to parts of the generated resources.<br/><br/>The result is a beautiful presentation that is built from the ground up out of generated resources like images, graphs, and checked/linted source code. It is buildable via a single command and does not assume any dependencies installed on your system other than the nix package manager.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/v4StENGDWZg/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/v4StENGDWZg/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/v4StENGDWZg/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/v4StENGDWZg/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT31M56S","dimension":"2d"},"statistics":{"viewCount":"47","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"A5c9kgDYXr8","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:41:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Matt Parsons - Exceptional Haskell - λC 2018","description":"Move over, monads, the real hard part of Haskell is here: exceptions! Haskell&#39;s runtime system supports advanced asynchronous exceptions, and while these enable some awesome programming idioms, they can be really difficult to understand. We&#39;re going to dive into Haskell&#39;s varying methods of error handling, from Either to classy prisms to IO, exploring the tradeoffs and advantages to different approaches. At the end of the talk, you&#39;ll be ready to handle anything GHC throws at you.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/A5c9kgDYXr8/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/A5c9kgDYXr8/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/A5c9kgDYXr8/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/A5c9kgDYXr8/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M19S","dimension":"2d"},"statistics":{"viewCount":"965","likeCount":"23","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"8GJ3ktELON8","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:39:31Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Mike Stay - Reflecting on Behavior - λC 2018","description":"Milner published the pi calculus in 1990, the same year that ARPANET was decommissioned and that Haskell 1.0 was released. Since that time, variants of pi calculus have found applications from analyzing cryptographic protocols to simulating chemical reactions and biological processes. One of the major problems with pi calculus was the lack of a type system. Functional programming languages have a clear denotational semantics: the meaning of a type is a set, and the meaning of a program is a function. A generic pi calculus process, however, is nondeterministic: messages sent simultaneously can arrive in any order, and we can model contention for resources. At the same time, a pi calculus process doesn&#39;t have a clear input and output: there is no production in the grammar corresponding to application. If pi calculus processes are not functions, what are they? And how do we reason about them? I&#39;ll talk about how denotational semantics is really a special case of operational semantics, how Caires&#39; spatial-behavioral type system lets us reason about security properties, how Meredith&#39;s reflection trick lets us derive a much more powerful version of the type system directly from a process calculus itself, and how we&#39;re putting all this to use on the blockchain.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/8GJ3ktELON8/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/8GJ3ktELON8/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/8GJ3ktELON8/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/8GJ3ktELON8/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M9S","dimension":"2d"},"statistics":{"viewCount":"44","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"hqhVCKwEAr4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:38:54Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Moiz Merchant - Functional Error Handling in Python - λC 2018","description":"I had the privilege of working on a functional Scala codebase a few years ago. During my 18-month adventure, I was introduced to error handling concepts from the depths of category theory. My first acquaintance was Option: value or no value, a container allowing me to deal with null values with a clean interface. Then came Try, slaying my utter disgust of exception abuse. Lastly, I stumbled onto Scalaz&#39;s \\/ (a right-biased Either). What a wonderful world I had been introduced to, error handled managed in a sane and clean way. Life was good.<br/><br/>Fast-forward 3 years: back into the land of Python. My second assignment at the new gig was to implement a fixed-length parser for an incoming file format. Easy, I thought to myself. Reaching down into my tool belt, my hands came up empty. Huh? I no longer had the magical ninja weapons to tame my errors. Sadness filled me. Refusing to accept my fate, I became resolute on forging my own tools.<br/><br/>The result is a tiny Pythonic library (inspired by Scalaz), implementing Option, Try, and Either. My goal is to keep the code as close to idiomatic Python as possible while still implementing the code in a functional way. The code should integrate seamlessly into existing Python without looking out of place like many other implementations I ran into. Python&#39;s many functional faces made this all possible: using Python&#39;s generator comprehension to implement a Haskell-like do construct, class construction to implement a Try constructor which returned the proper child type of Success/Failure on exception, and various operators available to implement aliases for swap and getOrElse.<br/><br/>Future goals include expanding functional abstractions/implementations and thinking about the usefulness of high abstractions.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/hqhVCKwEAr4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/hqhVCKwEAr4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/hqhVCKwEAr4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/hqhVCKwEAr4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT39M1S","dimension":"2d"},"statistics":{"viewCount":"60","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ZHL3K4vUDU0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:38:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Monica Quaintance - Chainweb: A Parallel chain Architecture for Massive Throughput - λC 2018","description":"Proof-of-work blockchain networks like Bitcoin, Litecoin and Ethereum are characterized by low throughput (5-15 transactions per second). Efforts to improve throughput through protocol modifications, such as block size increases, have no hope of reaching levels required to take on modern fiat-currency payment networks. However, efforts that seek to replace Proof-of-Work (Proof-of-Stake and variants) or integrate it with off-chain networks and processes (payment channels, side chains) degrade assurance, censorship resistance or trustlessness of the original design. Recovering and elaborating on early proposals for Bitcoin scaling, we present ChainWeb, a parallel-chain architecture which can combine hundreds to thousands of Proof-of-Work blockchains pushing throughput to 10,000 transactions per second and beyond. The network transacts a single currency, using atomic and trustless SPV (Simple Payment Verification) cross-chain transfers orchestrated at the application layer with capability and coroutine support in the Pact smart contract language. Chains incorporate each other&#39;s Merkle tree receipts to enforce a single super branch\u009d offering an effective hash power that is the sum of each individual chain&#39;s hash rate. In addition to massive throughput, other benefits accrue from having a truly parallelized smart-contract blockchain system.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ZHL3K4vUDU0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ZHL3K4vUDU0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ZHL3K4vUDU0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ZHL3K4vUDU0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT29M44S","dimension":"2d"},"statistics":{"viewCount":"42","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"C9x12Q7AGd4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:37:34Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Narek Asadorian - Functional Programming: The Enterprise Edition - λC 2018","description":"Despite its increasing popularity, functional programming is still stuck in the back seat when it comes to the enterprise. This talk aims to address common pitfalls in enterprise software engineering which can be avoided through the application of functional programming principles, as well as to introduce the clarity and maintainability inherent to functional code. In this talk, we will cover common computational effects including failure handling, IO and partiality using various functors and monads (with neither mentioned up front). We will also explore the &quot;softer&quot; side of things: teaching and advocating for FP at work, and strategies for coaching teammates off of imperative and side-effect ridden coding practices.<br/><br/>The material in the talk will focus on Scala specifically, but the principles should apply to any programming language supporting types. While enterprise software is implied in the title, the learnings and examples in the talk can be implemented in any commercial software development environment. The content presented is intended to have multiple levels of approachability: beginners will be exposed to FP concepts from a relatable and novel angle, while advanced programmers will learn new ways to approach and teach these concepts. Engineering managers will also gain an understanding of how functional code scales and remains maintainable.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/C9x12Q7AGd4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/C9x12Q7AGd4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/C9x12Q7AGd4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/C9x12Q7AGd4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT34M28S","dimension":"2d"},"statistics":{"viewCount":"97","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ydZ_fLwo9yI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:36:59Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nihil Shah - Cofree Comonads and their Uses - λC 2018","description":"Monads are one of the first abstractions taught to those entering the functional programming world. In this talk, I will define and give examples of its categorical dual: comonads. Comonads allow composition over structured input rather than structured output. With monads, composition in structured output allows functional programmers to work with effectful and non-deterministic computations. By contrast, comonads are able to model what I call &#39;superdeterminism&#39;: when a value, computed in a context, can be extended over the entire context. Some concrete use cases include: computing a running median, implementing a trie, and verifying a hash in a merkle tree. The primary focus of my talk will be on a particular class of comonads: cofree comonads. Cofree comonads, dual to free monads, are a product type the allow functional programmers to express seemingly infinite streams or trees of data. Using a cofree comonad, you can implement your own blockchain, DSL interpreter, and data stream processor.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ydZ_fLwo9yI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ydZ_fLwo9yI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ydZ_fLwo9yI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ydZ_fLwo9yI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT41M28S","dimension":"2d"},"statistics":{"viewCount":"278","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ZMC3MQCxvME","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:36:27Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikhil Barthwal - Cross Platform Mobile Application Development with F# - λC 2018","description":"F# is a relatively new, primarily functional programming language for the .NET platform. It is a statically-typed, managed functional language that is fully interoperable with other .NET languages like C#, Visual Basic.NET, etc. It builds on the power of the functional paradigm and combines it with the .NET object-oriented model, enabling the developer to use the best approach for a given problem. F# offers all the benefits of functional programming (FP), such as terse code leading to enhanced developer productivity, pure functions which are much easier to reason about, and side-effect free programming that eliminates a large class of bugs.<br/><br/>Xamarin platforms allows you the build mobile apps using F# with high code re-use between them. Typically, there is common code, which is where more of the app-specific logic resides, and then specific features of the platform can be leveraged using platform specific code (also in F#). Xamarin offers platform-specific mappings for iOS and Android as .NET libraries that F# code can use, and applications are compiled as either a .app file in iOS, or .apk file in Android.<br/><br/>This talk goes into the details of how the Xamarin platform works and will teach attendees how to build native apps for multiple platforms using a single F# code base.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ZMC3MQCxvME/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M17S","dimension":"2d"},"statistics":{"viewCount":"251","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dfTTgdlsSzo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:35:26Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikolai Kudasov - Building a Telegram Bot in Haskell (Part 1) - λC 2018","description":"Telegram is a popular messenger with a fairly easy way to construct and use bots. Bots are used to provide lightweight interfaces to many services or to help with various repetitive tasks. For instance, you can make a bot to keep track of your budget or work time, provide you a personalized news feed, monitor your GitHub repo activity, or simply make a conversation! Some even use a Telegram bot as a cryptowallet interface!<br/><br/>The Telegram Bot API makes it relatively easy to write a bot in virtually any programming language. And Python is a popular choice for this. However, I find Haskell to be more comfortable to write a bot in. A typical bot relies on some conversation state machine and handles many conversations concurrently, and Haskell allows a very simple yet powerful encoding of that logic.<br/><br/>In this workshop, you&#39;ll learn how to develop a simple Telegram bot with features like commands, notifications, custom keyboards, on-the-fly updating and inline mode. In the process, you will see what a development experience in Haskell may look like with just a minimal set of tools like Stack, GHCi, and ghcid.<br/><br/>The workshop assumes some basic Haskell knowledge. Ability to understand (simple) GHC error messages will help a great deal. Familiarity with applicative parsers might also help to better understand the bot&#39;s input processing, however, it&#39;s not at all necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dfTTgdlsSzo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M9S","dimension":"2d"},"statistics":{"viewCount":"755","likeCount":"16","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"hR2yX9fWQ7A","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:35:14Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Nikolai Kudasov - Building a Telegram Bot in Haskell (Part 2) - λC 2018","description":"Telegram is a popular messenger with a fairly easy way to construct and use bots. Bots are used to provide lightweight interfaces to many services or to help with various repetitive tasks. For instance, you can make a bot to keep track of your budget or work time, provide you a personalized news feed, monitor your GitHub repo activity, or simply make a conversation! Some even use a Telegram bot as a cryptowallet interface!<br/><br/>The Telegram Bot API makes it relatively easy to write a bot in virtually any programming language. And Python is a popular choice for this. However, I find Haskell to be more comfortable to write a bot in. A typical bot relies on some conversation state machine and handles many conversations concurrently, and Haskell allows a very simple yet powerful encoding of that logic.<br/><br/>In this workshop, you&#39;ll learn how to develop a simple Telegram bot with features like commands, notifications, custom keyboards, on-the-fly updating and inline mode. In the process, you will see what a development experience in Haskell may look like with just a minimal set of tools like Stack, GHCi, and ghcid.<br/><br/>The workshop assumes some basic Haskell knowledge. Ability to understand (simple) GHC error messages will help a great deal. Familiarity with applicative parsers might also help to better understand the bot&#39;s input processing, however, it&#39;s not at all necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/hR2yX9fWQ7A/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT54M59S","dimension":"2d"},"statistics":{"viewCount":"190","likeCount":"4","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"8_HsFrXhZlA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:34:42Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Paul Snively - Typed FP on the Job  Why Bother - λC 2018","description":"Good news: your organization&#39;s management team has expressed a willingness to explore functional programming with a statically-typed language. Bad news: neither they nor anyone else on your team has any deep experience with functional programming. Worse news: some members of your team are perfectly happy with your language, techniques, codebase, and processes and are skeptical at best, and outright hostile at worst, to functional programming. Your front-end developers, in particular, don&#39;t see the point of static typing. Intellectual honesty compels us to admit that pure typed FP has some significant up-front costs, especially when you include the inevitable learning curve. Your colleagues want to know: why bother?<br/><br/>It&#39;s a legitimate question, especially since your team is probably not in the pure typed FP business for its own sake. Fortunately, the question has an answer. We&#39;ll explore and unpack that answer and some of the implications of doing pure typed FP that inform it. Most examples will be drawn from the speaker&#39;s experience with pure typed FP in Scala, but the concepts we&#39;ll explore apply equally well to any pure typed approach to FP, such as in Haskell or PureScript.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/8_HsFrXhZlA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT38M57S","dimension":"2d"},"statistics":{"viewCount":"535","likeCount":"16","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"vhKNBISDycw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:34:10Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Pawel Szulc - Understanding Distributed Calculi in Haskell - λC 2018","description":"In the late 1960s, it was already a well-established fact that any arbitrary, complex programming language can be represented as an evidently tinier &quot;core&quot; language. Lambda calculus, or Turing machines, are the most well-known examples of such languages. However, they all shared a common constraint: the ability to model only sequential computations. With the rise of distributed systems and multicore architectures, industry has needed a new formalism to represent calculations that run concurrently. This talk is an introduction to process calculus, a family of related formalisms that model concurrent systems. They describe high-level interactions between a collection of independent processes and also algebraic laws that allow process descriptions to be analyzed and their equivalences reasoned about.<br/><br/>This talk describes in detail two process calculi: pi Calculus and its natural successor rho calculus. A Haskell library called distributed-process (also known as Cloud Haskell) will be used to show live code examples. Cloud Haskell is a library which allows message-passing programming style, similar to the one known in Erlang or Akka (Scala). Attendees should be familiar with simple Haskell syntax and lambda calculus, however some limited introduction to both the language and the formalism will be covered, as well.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/vhKNBISDycw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","haskell","distributed computing"]},"contentDetails":{"duration":"PT47M9S","dimension":"2d"},"statistics":{"viewCount":"152","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"4IPXSj5NVxQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:33:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Reid Evans - Abstract Algebras and Where to Find Them  Magmas, Monoids, and More! - λC 2018","description":"The structures of abstract algebra appear over and over again in the real world from the simple addition of numbers and string concatenation to modular architectural patterns for large enterprise systems and beyond. The best part about these abstractions is that we can leverage the simpler examples to begin building an intuition for the larger examples. So what are magmas? Other than alliteration, what do they have in common with monoids? This presentation will give you the skills needed to begin spotting these structures in the wild, as well as tips for using them to solve problems large and small.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/4IPXSj5NVxQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M6S","dimension":"2d"},"statistics":{"viewCount":"175","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"3USNLflRRUA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:52Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Robert Kluin - Introducing A Functional Language At Work - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/A%20Developer%E2%80%99s%20Guide%20to%20Introducing%20A%20Functional%20Language%20At%20Work.pdf<br/><br/>Introducing functional programming within an organization is challenging. This talk is a retrospective on two implementations, one an ongoing success and the other a failed attempt. The goal is to help grow our community by expanding the usage of functional languages.<br/><br/>We first attempted to introduce Scala. We quickly discovered the reasons we used to justify choosing Scala were actually challenges that led to us abandoning the effort. We selected the perfect technical problem for the language to demonstrate its value. The flexibility of the language, build tooling, and the runtime architecture became liabilities. In hindsight, the problems we faced should have been expected.<br/><br/>We firmly believed in the merits of functional languages, so we reflected on our prior failure and decided to try again. We chose a language no one was as excited about: Elm. The team was a semi-reluctant guinea pig, but they quickly became Elm evangelists. The team&#39;s pace of delivery and low defect rate validated our decision to try introducing another functional language.<br/><br/>Comparing these two projects will help guide the introduction of not only new functional programming languages, but new technologies in general. The takeaways include insights into selecting the right pilot projects and teams, and how ancillary technologies will impact your chances of success.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/3USNLflRRUA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT42M10S","dimension":"2d"},"statistics":{"viewCount":"100","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"9PanQD_lzZw","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:16Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 1) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/9PanQD_lzZw/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M7S","dimension":"2d"},"statistics":{"viewCount":"407","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"Ay80PHwOgSo","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:09Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 2) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Ay80PHwOgSo/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT51M58S","dimension":"2d"},"statistics":{"viewCount":"90","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"lfT4Ri6cyVU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:32:03Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 3) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/lfT4Ri6cyVU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M36S","dimension":"2d"},"statistics":{"viewCount":"51","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"YgqZks_ypD0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:57Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 4) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/YgqZks_ypD0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M57S","dimension":"2d"},"statistics":{"viewCount":"27","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"GgP7504ee8I","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:52Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 5) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/GgP7504ee8I/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M12S","dimension":"2d"},"statistics":{"viewCount":"16","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"qWy0ldhmIxk","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:46Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Roman Gonzalez - Rock Solid Haskell Services (Part 6) - λC 2018","description":"Independently of the language at hand, implementing concurrent applications is always a tricky task to get right. There are many factors involve:<br/>- Misunderstanding of the runtime behavior of an algorithm.<br/>- Threads may silently fail when an exception occurs.<br/>- Effective communication in between threads is a hit-or-miss.<br/>- Asynchronous exceptions can happen at unexpected times.<br/>- Memory leaks caused by improper resource cleanup.<br/><br/>In this workshop, through various coding exercises in Haskell, my goal is for participants to get a better idea of what could go wrong in their applications and later, to be able to recognize what tools are at their disposal to mitigate a few of those error scenarios. Some of the points that we will cover:<br/>- Supervision trees and how can you use them to bulkhead error in parts of your application.<br/>- Circuit Breakers to deal with failures happening at a third party level.<br/>- Usage of semaphores to deal with controlled resource allocation.<br/>- Usage of timeouts to avoid indefinite resource allocation.<br/>- Strategies for effective thread communication using STM.<br/>- Quick overview of interprocess mechanisms to communicate threads/applications without losing messages on catastrophic failure.<br/>- Cleanup strategies to not leave resources hanging in error scenarios.<br/><br/>This workshop is targeted to an audience that is familiar with Haskell and has had partial experience with threads and concurrency. Participants will need to have a computer with Haskell installed to work on a Stack/Cabal project that I will provide to them.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/qWy0ldhmIxk/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT33M5S","dimension":"2d"},"statistics":{"viewCount":"27","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"gHAn5Xp8XCA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:07Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Sandy Vanderbleek - Athena: A Declarative Language For Proofs In Computer Science - λC 2018","description":"Athena is a modern language for proofs in computer science. It is declarative and not tactic based which makes it stand out among similar languages such as Coq and Isabelle. The syntax and concepts will be introduced at a comfortable pace for anyone familiar with abstract datatypes and pattern matching. As an example application we will do proofs about operations on the Option Type.<br/><br/>Install Athena to follow along at the command line using the instructions here:http://proofcentral.org/athena/1.4/","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/gHAn5Xp8XCA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M43S","dimension":"2d"},"statistics":{"viewCount":"81","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"49QvM4pTeDY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:31:01Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ryan Orendorff &amp; Daniel Hensley - Introduction to Linear Type Systems and Linear Haskell - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/LinearTalk_handout.pdf<br/><br/>Many of the current developments in programming language theory and practical coding revolves around demonstrating that certain classes of bugs are not possible within a given program; example bug classes include control flow errors, mismanaged/implicit state, and dereferencing errors. Proving that certain bugs are impossible in a program allows programmers to reason at a higher level of abstraction without the worry of leaky abstractions causing obscure behaviors in their programs.<br/><br/>One particularly vexing class of bugs are those that involve manipulating objects that mutably change within the lifetime of a program, such as enforcing access APIs for external resources and in-place mutable updates. Example bugs include attempting to manipulate a file through a file handler that has been closed and altering the state of some object from multiple threads simultaneously. What makes these bugs challenging to eliminate at compile time is that the information required to determine the lifetime of these objects is not encoded in the type system of most languages.<br/><br/>Linear Haskell is an extension to the Haskell language that uses linear types to eliminate this class of mutable state bugs, which enables the compiler to understand the context in which an object is used relative to other parts of the program or relative to the external world. In this talk we will examine the underlying type theory of Linear Haskell as well as examples of how this extension prevents this class of bugs from occurring. We will compare the type system introduced in Linear Haskell with other methods that aim to solve a similar class of bugs, including monadic approaches and the uniqueness type systems in Idris and Rust. Attendees will leave with an understanding of the inner workings of linear type theory along with practical examples of projects that use linear types.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/49QvM4pTeDY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT48M35S","dimension":"2d"},"statistics":{"viewCount":"252","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"jb7QX-6Y858","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:30:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Seth House - Why JavaScript Programmers Should Learn Algebraic Data Types - λC 2018","description":"The JavaScript ecosystem is awash with slightly differing implementations of the same thing view libraries, MVC frameworks, state management, async helpers, streams, utilities over and over again. JavaScript fatigue is real, and spending time to learn new things is an investment that must be justified.<br/><br/>ADTs provide a unique and concise API of specifically interlocking pieces that allow building complete programs from simple, individual parts. Whole libraries and frameworks can give way to common and well studied and understood concepts. The often repeated and rarely understood or practiced programming mantras of single-responsibility, composition, and abstraction are made explicit and knowable with ADTs.<br/><br/>The goal of this presentation is to excite and encourage developers who have little to no knowledge of ADTs to want to learn. We will focus single-mindedly on practical, everyday problems and demonstrate a working, minimal solution to each problem in plain JavaScript. We will deemphasize, but not avoid, terminology and implementation. Each topic will conclude with next steps and learning resources.<br/><br/>Some of the problems we will cover are: processing pipelines, null checking, error handling, branching logic, async management, merging/reducing, reactive streams, state management, effects management, declarative UIs, and how to apply your own everyday data to all those scenarios in a composable, functional way.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/jb7QX-6Y858/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","javascript"]},"contentDetails":{"duration":"PT55M1S","dimension":"2d"},"statistics":{"viewCount":"165","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"dXRggl82brQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:29:34Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Simon Hafner - A Typeclass Primer for OO People - λC 2018","description":"This talk will explain how to connect functions to types using typeclasses. It will mention common use cases, problems, and the implementations of typeclasses in both Scala and Haskell. No prior knowledge of Scala or Haskell is required.<br/><br/>In object-oriented programming, objects consist of three components: data, methods, and state. When written in an FP style, these objects will only consist of data and pure methods. However, there is no requirement for data and methods/functions to stay together, because there&#39;s no associated state.<br/><br/>Because a method/function doesn&#39;t need an attached object anymore, it&#39;s also possible to attach it to the type instead. The concept of attaching different functions to different types, with all the functions of the same signature, is called a typeclass.<br/><br/>A typeclass is a way to declare an API, similar to an interface in Java. It is then implemented for different types. Each implementation is then associated with the corresponding type. This idea will be demonstrated with the Functor typeclass. Typeclasses are also a strict superset of interfaces in terms of implementation power. This will be demonstrated with the Monoid typeclass.<br/><br/>The concept of typeclasses will be applied in two separate use cases: counting words in documents and JSON codecs. Counting words will be based on Monoids, and the JSON codecs will demonstrate the association between types and functions. Each of the examples will also showcase some of the problems with typeclasses.<br/><br/>These use cases will be demonstrated in Scala and Haskell in order to highlight the differences in their implementations of typeclasses. The differences are mostly in the resolution on which function to pick and in the so-called typeclass coherence.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/dXRggl82brQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M18S","dimension":"2d"},"statistics":{"viewCount":"180","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"E-mANbOvzEQ","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:28:20Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephan Boyer - Proving Theorems and Certifying Programs with Coq - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/Stephan-Boyer-Coq.pdf<br/><br/>Have you ever wanted to formally prove an algorithm correct or a theorem true? This talk will show you how! We&#39;ll cover the fundamentals of computer-assisted theorem proving using Coq, one of the most popular proof assistants. Coq is a functional programming language with a type system that can encode essentially any mathematical proposition.<br/><br/>It is often said that formal verification is difficult. I will argue a more nuanced position: formal verification is tedious, but it need not be any more challenging than the underlying ideas behind the proof itself. Coq is a small language, and you can learn the basics in an hour. Once you&#39;ve mastered the foundations, what you can prove is limited only by the time you&#39;re willing to invest.<br/><br/>Most introductions to Coq survey the landscape from a bird&#39;s-eye view. You start by building proof scripts using high-level &quot;tactics&quot; and later you&#39;re introduced to the actual proofs generated by these tactics. For some, this is a bit too magical. You learn to prove simple theorems but lack intuition for what the tactics are actually doing. That conundrum was frustrating for me when I was learning Coq in graduate school. This talk, in contrast, will feature no magic.<br/><br/>Instead, we will approach Coq from the perspective of a functional programmer. We&#39;ll start with the syntax, which will be familiar to Haskell or ML programmers. We&#39;ll learn how to encode propositional logic in data types, which can be done in any functional language. Then we&#39;ll see how to encode quantifiers using dependent types, which completes the foundation of higher-order logic. Finally, we&#39;ll learn how to automate our proofs using Coq&#39;s tactic language. The more you automate, the shorter and more robust your proofs become!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/E-mANbOvzEQ/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","Coq"]},"contentDetails":{"duration":"PT55M18S","dimension":"2d"},"statistics":{"viewCount":"113","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"VTZtuYjuLAM","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:27:29Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephan Boyer - Unconference Coq - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/VTZtuYjuLAM/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/VTZtuYjuLAM/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/VTZtuYjuLAM/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/VTZtuYjuLAM/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M32S","dimension":"2d"},"statistics":{"viewCount":"15","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"ej-_FUZClWc","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:26:33Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephen Compall - Opaque Types To Infinity - λC 2018","description":"Scala&#39;s type members have many interesting applications. One surprising application to come into use recently has been true newtypes in the Haskell tradition.<br/><br/>The language for declaring the new type\u009d is just a little trick, but a rich language for describing the newtypes relationship with other types waits to be uncovered.<br/><br/>This talk will show attendees how to use a type member to create a simple opaque type, moving on to demonstrate how to progressively reveal\u009d as many facts about the type as the programmer might desire, whether following a traditional subtyping or an FP-native typeclass approach. It will conclude by showing off the new Fix [infinite] type in Scalaz 8, a new Scala encoding for generalized recursion schemes, and explaining why it works.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ej-_FUZClWc/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT53M41S","dimension":"2d"},"statistics":{"viewCount":"151","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"tfG7T54MhIU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:25:17Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Stephen Pimentel - Propositions as Types for Beginners in Haskell - λC 2018","description":"This session is a gentle introduction to &quot;propositions as types,&quot; also known as the Curry-Howard isomorphism, aimed at beginners in Haskell. Its purpose is practical rather than theoretical: to build intuitions for thinking about and coding functions with parametric, polymorphic types.<br/><br/>Propositions as types is a notion that deeply relates the fields of logic and computation. In academia, its often applied to sophisticated logics at the cutting edge of programming language research. However, the core of propositions as types can be easily explained, and it helps us learn an approach to designing Haskell code that starts with types.<br/><br/>While the Haskell type system may seem easy enough to grasp, beginners often find some of its implications confusing. For example, the inverse relation between the generality of a function type and the number of its implementations can seem counterintuitive. Propositions as types will serve as our framework to build up the key intuitions, letting us recast from a logical perspective the common experience of playing type tetris\u009d with GHC.<br/><br/>We&#39;ll start with the basic ideas of propositions as types and programs as proofs, where type inhabitation corresponds to propositional truth and proof normalization to program evaluation. We&#39;ll explain how the correspondence applies to the &quot;sound&quot; subset of Haskell (i.e., without bottom, non-termination, or general recursion). The core of the session will be a series of simple examples of Haskell types for familiar functions involving basic structures like tuples, Maybe, and Either.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/tfG7T54MhIU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT38M10S","dimension":"2d"},"statistics":{"viewCount":"766","likeCount":"23","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"43hWxtFFV9M","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:22:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Steven Syrek - Category Theory for People who Can&#39;t be Bothered to Learn It (Part 1) - λC 2018","description":"Let&#39;s take a different approach to learning about category theory. Instead of ascending a tower of abstractions through diagram chasing and cranial contortions, we&#39;re going to concentrate in this workshop on the payoffs of thinking about your code categorically.<br/><br/>To that end, we&#39;ll explore categorical objects as reusable patterns that provide powerful guarantees to our programs, morphisms as vehicles for more explicitly structuring our code, and the mathematical properties we can take advantage of when our problem solving process is aligned with even the most trivial elements of this deep and sophisticated field. We will also discuss composition, algebraic data types, and the basics of functoriality, all without having to delve into abstruse terminology or memorize precise rules for drawing arrows between dots.<br/><br/>To demonstrate the universality of this process, we will work directly in code, using both JavaScript and Haskell the former, because of its ubiquity and the latter for its expressiveness. By translating back and forth between syntactic dialects of computation, we will see that the underlying idiom is the same. Once you learn the ideas presented in this workshop, you&#39;ll be able to rethink the way you design your code and also teach these concepts to others.<br/><br/>As functional programmers, we are often accused of advocacy for ideas that are too complex or too impractical for working programmers to use. Our seeming obsession with a branch of mathematics that even many mathematicians consider absurd doesn&#39;t help matters.<br/><br/>The contrary position is that FP, with its basis in math and logic, leverages the genuine simplicity and elegance of these formal systems to help us write code that is coherent, consistent, and best of all law-abiding. Although the learning curve can indeed be steep, the longer term benefits in code readability, testability, and maintainability are worth the initial investment.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/43hWxtFFV9M/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT44M42S","dimension":"2d"},"statistics":{"viewCount":"333","likeCount":"7","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"XKeD5_wEvXI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:21:56Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Steven Syrek - Category Theory for People who Can&#39;t be Bothered to Learn It (Part 2) - λC 2018","description":"Let&#39;s take a different approach to learning about category theory. Instead of ascending a tower of abstractions through diagram chasing and cranial contortions, we&#39;re going to concentrate in this workshop on the payoffs of thinking about your code categorically.<br/><br/>To that end, we&#39;ll explore categorical objects as reusable patterns that provide powerful guarantees to our programs, morphisms as vehicles for more explicitly structuring our code, and the mathematical properties we can take advantage of when our problem solving process is aligned with even the most trivial elements of this deep and sophisticated field. We will also discuss composition, algebraic data types, and the basics of functoriality, all without having to delve into abstruse terminology or memorize precise rules for drawing arrows between dots.<br/><br/>To demonstrate the universality of this process, we will work directly in code, using both JavaScript and Haskell the former, because of its ubiquity and the latter for its expressiveness. By translating back and forth between syntactic dialects of computation, we will see that the underlying idiom is the same. Once you learn the ideas presented in this workshop, you&#39;ll be able to rethink the way you design your code and also teach these concepts to others.<br/><br/>As functional programmers, we are often accused of advocacy for ideas that are too complex or too impractical for working programmers to use. Our seeming obsession with a branch of mathematics that even many mathematicians consider absurd doesn&#39;t help matters.<br/><br/>The contrary position is that FP, with its basis in math and logic, leverages the genuine simplicity and elegance of these formal systems to help us write code that is coherent, consistent, and best of all law-abiding. Although the learning curve can indeed be steep, the longer term benefits in code readability, testability, and maintainability are worth the initial investment.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/XKeD5_wEvXI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M59S","dimension":"2d"},"statistics":{"viewCount":"237","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"5ZAFEylHdiU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:21:44Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Ted Blackman Ford - Urbit&#39;s Build System - λC 2018","description":"","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/5ZAFEylHdiU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/5ZAFEylHdiU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/5ZAFEylHdiU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/5ZAFEylHdiU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M31S","dimension":"2d"},"statistics":{"viewCount":"531","likeCount":"13","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"2-8gC8ue1GI","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:15:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Thomas Honeyman - Designing Flexible Open source Components in Halogen - λC 2018","description":"As developers, we rely on libraries built and battle-tested by others rather than write everything from scratch. As frontend developers, this often means using pre-built components. Components render HTML for you and affect how your web app looks and behaves. They allow some customization via CSS classes or configuration records. This leads to a large API and a complex implementation to allow for as many use cases as possible. Customizing the component to your specific use case can be nearly as costly as writing a new one from scratch. These limitations arise largely because the component performs rendering for you. But what if it didn&#39;t?<br/><br/>The `purescript-halogen-select` library demonstrates another approach. The library provides essential behaviors for selection user interfaces (like dropdowns, typeaheads, and image pickers) as a group of Halogen components. But you won&#39;t find a single render function in the code.Â Instead, with the help of a few `getProps` helpers, you can write your HTML rendering however you&#39;d like. You can freely include your own queries and the library will return them to be run. You can even use any data you want from your parent state in your render functions. The library manages user interaction, state, accessibility, and logic; you are responsible for rendering HTML depending on that state.<br/><br/>This talk will:<br/>- Describe the design and implementation of the `purescript-halogen-select` library. <br/>- Walk through how a company uses it in production to build dropdowns, typeaheads, calendar pickers, and other components.<br/>- Show how you can use props helpers and the `Store` comonad to design open-source Halogen components without limiting users from rendering HTML as they see fit.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2-8gC8ue1GI/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT47M39S","dimension":"2d"},"statistics":{"viewCount":"377","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"GPwtT31zKRY","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:27Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - An Intuition for List Folds -  λC 2018","description":"In this talk, we go back to first principles, defining and examining the definition for a cons list, then take a look at the ubiquitous right and left fold functions on a list.<br/><br/>The primary focus of this talk is to develop an intuition for how these functions work so that we can best decide when to apply them. Multiple programming languages will be used to help emphasize the independence of the gained intuition. This talk will generally be interactive with the audience as we solve problems and build confidence in applying our new knowledge<br/><br/>Knowing how to apply the various list fold functions is a common question of students of FP. This talk aims to provide a solid, reliable answer to this question. No prior understanding of list folds is necessary.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/GPwtT31zKRY/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT52M57S","dimension":"2d"},"statistics":{"viewCount":"333","likeCount":"10","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"K1UjjcdBYp0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - Introduction to FP Using Haskell (Part 1) - λC 2018","description":"We will be spending the day learning the fundamentals of Functional Programming (FP) using the Haskell programming language.Â This one day session is targeted to experienced industry programmers who are looking to break into functional programming and develop the rudimentary skills and techniques that enable continued, independent study. A refresher on Haskell syntax will be provided. However, it is highly recommended to practice with the syntax and development tools prior to the workshop in order to obtain the best outcome for the day.<br/><br/>You will be required to bring a suitable development machine (portable) for working through the exercises. You will also need to install the Glasgow Haskell Compiler, version 7.8 or higher, on that machine prior to the day.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/K1UjjcdBYp0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT59M17S","dimension":"2d"},"statistics":{"viewCount":"578","likeCount":"13","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"Jpt5eLHeZC4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:12:20Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Tony Morris - Introduction to FP Using Haskell (Part 2) - λC 2018","description":"We will be spending the day learning the fundamentals of Functional Programming (FP) using the Haskell programming language.Â This one day session is targeted to experienced industry programmers who are looking to break into functional programming and develop the rudimentary skills and techniques that enable continued, independent study. A refresher on Haskell syntax will be provided. However, it is highly recommended to practice with the syntax and development tools prior to the workshop in order to obtain the best outcome for the day.<br/><br/>You will be required to bring a suitable development machine (portable) for working through the exercises. You will also need to install the Glasgow Haskell Compiler, version 7.8 or higher, on that machine prior to the day.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/Jpt5eLHeZC4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT46M55S","dimension":"2d"},"statistics":{"viewCount":"299","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"0y0EuoToTco","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:26Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 1) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/0y0EuoToTco/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT43M47S","dimension":"2d"},"statistics":{"viewCount":"269","likeCount":"2","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"i-H_MqhRQNU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:22Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 2) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/i-H_MqhRQNU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT40M41S","dimension":"2d"},"statistics":{"viewCount":"75","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"AiHoLO054qE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:19Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 3) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/AiHoLO054qE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT31M49S","dimension":"2d"},"statistics":{"viewCount":"58","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"C7ImHqsKq4k","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:15Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 4) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/C7ImHqsKq4k/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT20M56S","dimension":"2d"},"statistics":{"viewCount":"30","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"a_CVCA2O4l0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:09Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 5) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/a_CVCA2O4l0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT25M9S","dimension":"2d"},"statistics":{"viewCount":"29","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"5zRkUhcs7PA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:11:05Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Valentin Kasas &amp; Olivier Girardot - Recursion Schemes Without the Barbed Wire (Part 6) - λC 2018","description":"Everyone has read the seminal paper, &quot;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire,&quot; right? I haven&#39;t, either. But we all agree that the subjects of folding, recursion, and algebraic datatypes matter. Yet we often have a hard time finding ways to apply them in our day-to-day programming lives.<br/><br/>My goal for this workshop is to show you how we can leverage recursion schemes to handle Real World Problems and yield Business Value. For that matter, we&#39;ll put ourselves in the shoes of a team of data engineers tasked to build a new data lake.<br/><br/>As a data engineer, your mission is to make sure that data is well-structured and amenable to large scale processing. Data often comes in semi-structured formats (like JSON or CSV) and your first job is to validate it against a given schema and transform it into more suitable formats like Parquet or Avro.<br/><br/>After an introduction to the theory behind recursion schemes, we&#39;ll work through a series of warm-up exercises together. These exercises will get you started developing some of the basic intuition necessary for understanding all of the concepts we will cover. You&#39;ll find that if you can achieve this basic understanding, the entire topic is easily accessible with a bit of patience and practice.<br/><br/>During the remainder of the session, we will use the recursive nature of schemas to build the main components of our data ingestion pipeline (data validation, transformation between different formats, and so on). Each exercise will be the occasion to learn about a new recursion scheme and its associated techniques and patterns.<br/><br/>At the end of the day, we might not have found a use for the exotic zygohistomorphic-prepromorphism, but we&#39;ll certainly have gained a solid grasp of its more common siblings!","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/5zRkUhcs7PA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT23M33S","dimension":"2d"},"statistics":{"viewCount":"85","likeCount":"0","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"2bPRvmoIGi0","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:43Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind Glasgow Haskell Compiler Internals (Part 1) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/2bPRvmoIGi0/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT56M42S","dimension":"2d"},"statistics":{"viewCount":"1546","likeCount":"31","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"KTyg-52T9i4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:39Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 2) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/KTyg-52T9i4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT49M10S","dimension":"2d"},"statistics":{"viewCount":"467","likeCount":"14","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"7P0aCM5mm80","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:35Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 3) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/7P0aCM5mm80/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT58M3S","dimension":"2d"},"statistics":{"viewCount":"354","likeCount":"7","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"ewM3NRsOxm4","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 4) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/ewM3NRsOxm4/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT57M44S","dimension":"2d"},"statistics":{"viewCount":"186","likeCount":"6","dislikeCount":"1","favoriteCount":"0","commentCount":null}},{"id":"a9_NCwbxZqg","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:28Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 5) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/a9_NCwbxZqg/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT1H13S","dimension":"2d"},"statistics":{"viewCount":"173","likeCount":"5","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"oRTlbblqxWU","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:08:25Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vitaly Bragilevsky - Type Theory Behind the Glasgow Haskell Compiler Internals (Part 6) - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/ghc-tt.pdf<br/><br/>The Glasgow Haskell Compiler is unique among other industrial-strength compilers in that its implementation relies heavily on advanced type theory. During compilation, the source code in Haskell is translated into the small internal functional language called GHC Core, which is in fact a relatively simple extension of typed lambda calculus. This workshop is devoted to the GHC Core and its relationship to type theory.<br/><br/>After a short introduction on the GHC compilation pipeline and the role of the GHC Core language, I will continue with a description of the simply typed lambda calculus and basic elements of type theory, such as typing rules, type checking, type inference, type erasure, and term evaluation. Then, I will introduce the lambda cube and describe all its axes, which represent different forms of abstraction in lambda terms and their combinations. System F, which is one of the lambda cube vertices, with the addition of algebraic datatypes, served as the GHC Core language for a long time.<br/><br/>Development of Haskell features means extending GHC Core. I will follow the years of Haskell development, showing how GHC Core changed while adding generalized abstract data types, type families, data kinds, type and kind equality, etc. I will end up with the most recent modifications of GHC Core aimed to bring the power of dependent types into Haskell. Every extension will be described at the levels of both its external and internal languages along with the motivation behind it, the algorithms of translation it uses, and its type-theoretic properties.<br/><br/>Prerequisites for this workshop include knowledge of Haskell at a beginner&#39;s level, but I will not assume any knowledge of lambda calculus or type theory.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/oRTlbblqxWU/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming","Haskell"]},"contentDetails":{"duration":"PT1H30S","dimension":"2d"},"statistics":{"viewCount":"262","likeCount":"6","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"xNJHw8E_36g","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:07:21Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Vlad Patryshev - A Gentle Introduction to Modern Model Theory -  λC 2018","description":"Model theory has been around for decades, but it&#39;s still an obscure area, and is frequently misunderstood and misinterpreted. The version of model theory that was known before F.W. Lawvere was focused on first-order logic and its interpretation in set theory. So the traditional method of teaching any theory in math is strangely based on set theory.<br/><br/>The modern version of model theory starts with a clear distinction between a theory and a model and between two kinds of theories: algebraic and geometric. In the light of this approach, category theory is viewed as a theory that does not depend on set theory (and neither does set theory itself depend on set theory).<br/><br/>In this talk, I&#39;ll show specific examples of theories and their models and hope to dispel certain popular superstitions about the role of types, axioms, and theorems.","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/xNJHw8E_36g/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/xNJHw8E_36g/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/xNJHw8E_36g/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/xNJHw8E_36g/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT50M38S","dimension":"2d"},"statistics":{"viewCount":"1300","likeCount":"20","dislikeCount":"2","favoriteCount":"0","commentCount":null}},{"id":"lG0ufdnGAgA","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-12-20T19:04:32Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"William Harvey - Metaphorisms  Deriving Divide and Conquer Recursive Programs - λC 2018","description":"slides: https://github.com/lambdaconf/lambdaconf-2018/blob/master/LC18-slides/LambdaConf%202018%20-%20Harvey.pdf<br/><br/>Functional programmers often think of a program specification as a set of inputs, a set of outputs, and a desired functional relation between them. Given a specification, a functional programmer will construct a program (i.e., a function) by composing functions together to hopefully implement the desired relation. However, thinking of some program specifications strictly in terms of functions, rather than more general relations, can be awkward or confusing.<br/><br/>The Bird-Meertens formalism (BMF), on the other hand, provides an alternative toolbox for constructing and reasoning about program specifications using a categorical calculus of relations. If a relational specification satisfies certain theorems, BMF provides a formulaic method for transforming the specification into a functional program.  This process is known as program derivation or programming from specifications.<br/><br/>In this talk, we will explore Oliveira&#39;s concept of metaphorisms, a class of relational program specifications that are inspired by metaphors in language.  Like adjunctions, metaphors arise everywhere (&quot;all the world is a stage,&quot; &quot;time is money,&quot; &quot;a monad is a burrito&quot;). The linguistic structure of a metaphor can be distilled to three ingredients (tenor, vehicle, and a shared attribute) and categorified as a relational cospan. A metaphorism is a program specification that takes on the form of such a categorified metaphor. Intuitively, a metaphorism describes a set of possible solutions to a problem, and an optimization criterion for choosing a &quot;best&quot; solution among these candidates.<br/><br/>With a suitably crafted metaphorism, we put on our text mining boots and embark on a quest to implement a purely functional, linear-time algorithm for suffix array construction.<br/><br/>Double-Blind Committee Selection","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/lG0ufdnGAgA/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/lG0ufdnGAgA/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/lG0ufdnGAgA/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/lG0ufdnGAgA/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT49M2S","dimension":"2d"},"statistics":{"viewCount":"88","likeCount":"3","dislikeCount":"0","favoriteCount":"0","commentCount":null}},{"id":"T-MngXNbrIE","snippet":{"channelTitle":"LambdaConf","publishedAt":"2018-10-10T18:50:23Z","channelId":"UCEtohQeDqMSebi2yvLMUItg","title":"Alejandro Serrano Mena - Book Of Monads: An Interview -  λC 2018","description":"https://www.amazon.com/Book-Monads-practice-applied-problems-ebook/dp/B07JNZHYLT","thumbnails":{"default":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/default.jpg","width":120,"height":90},"medium":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/mqdefault.jpg","width":320,"height":180},"high":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/hqdefault.jpg","width":480,"height":360},"standard":{"url":"https://i.ytimg.com/vi/T-MngXNbrIE/sddefault.jpg","width":640,"height":480}},"tags":["LambdaConf","Conference","Functional Programming"]},"contentDetails":{"duration":"PT21M54S","dimension":"2d"},"statistics":{"viewCount":"144","likeCount":"1","dislikeCount":"0","favoriteCount":"0","commentCount":null}}]}');
			const DateTime = luxon.DateTime,
				  Duration = luxon.Duration,
			      formatVideoTime = function formatVideoTime(time){
						const duration = Duration.fromISO(time),
							  format = duration.hours < 0 ? "mm:ss" : "HH:mm:ss";

						return duration.toFormat("mm:ss");
					},

				  renderPlaylist = function renderPlaylist(pl){
						$(".playlist").html(pl.videos.map(itemTemplate).join(''))
				  },

				  renderPlaylistInfo = function renderPlaylistInfo(pl){
						$(".playlist-info").html(playlistInfoTemplate(pl))

				   },

					sortBy = function sortBy (pl, countField){

						var items = pl.videos.sort(function(a, b){
								var aa = parseInt(a.statistics[countField]),
									bb = parseInt(b.statistics[countField]);

								if( aa < bb)
									return 1;
								if( aa > bb)
									return -1;
								return 0;
							});
						return {playlistInfo:pl.playlistInfo,videos:items};
				    },
				   sortAndRender = function sortAndRender(pl, countField){
						var _pl =  sortBy(pl, countField)
						renderPlaylist(_pl);
				   };
			const itemTemplate = ( item ) => `
			  <li class="item">
				<div class="thumbnail">
					<div class="thumbnail-video">
                        <img src="${item.snippet.thumbnails.medium.url}"></img>
                        <span class="thumbnail-video-duration label">${formatVideoTime(item.contentDetails.duration)}</span>
					</div>
					<div class="thumbnail-description">
						<h3 class="title description-item"><a target="_blank" href="https://www.youtube.com/watch?v=${item.id}">${item.snippet.title}</a></h3>
						<div class ="description description-item">${item.snippet.description}</div>
						<div class="published-at description-item">
							<span class="label">${DateTime.fromISO(item.snippet.publishedAt).toLocaleString(DateTime.DATE_MED)}</span>
						</div>
					</div>
				</div>
				<ul class="statistics-block">
					<li>
						<span class="label view-count">${item.statistics.viewCount}</span>
						<span  class="label">views</span>
					</li>
					<li>
						<span class="label dislike-count" >${item.statistics.dislikeCount}</span>
						<span class="label">dislikes</span>
					</li>
					<li>
						<span class="label favorite-count">${item.statistics.favoriteCount}</span>
						<span class="label">favorites</span>
					</li>
					<li class="statistics">
						<span class="label comment-count">${item.statistics.commentCount}</span>
						<span class="label">comments</span>
					</li>
				</ul>
			</li>
			`;
			 const playlistInfoTemplate = ( pl ) => `

				<h1 class="playlist-title"><a target="_blank" href="https://www.youtube.com/playlist?list=${pl.playlistInfo.id}">${pl.playlistInfo.snippet.title} ( ${pl.videos.length} videos)</a></h1>
				<div>${pl.playlistInfo.snippet.description}</div>
				<div><a target="_blank" href="https://www.youtube.com/channel/${pl.playlistInfo.snippet.channelId}">${pl.playlistInfo.snippet.channelTitle}</a></div>


			 `;

			$(function() {
				var renderPlaylist = function renderPlaylist(pl){
						$(".playlist").html(pl.videos.map(itemTemplate).join(''))
					},
					renderPlaylistInfo = function renderPlaylistInfo(pl){
						$(".playlist-info").html(playlistInfoTemplate(pl))

					},
					sortBy = function sortBy (pl, countField){

							var items = pl.videos.sort(function(a, b){
									var aa = parseInt(a.statistics[countField]),
										bb = parseInt(b.statistics[countField]);

									if( aa < bb)
										return 1;
									if( aa > bb)
										return -1;
									return 0;
								});
							return {playlistInfo:pl.playlistInfo,videos:items};
					},
					sortAndRender = function sortAndRender(pl, countField){
						var _pl =  sortBy(pl, countField)
						renderPlaylist(_pl);
					};


				$(".sorting-option").click(function(event){
					event.preventDefault();
					var $this = $(this),
						countField = $this.attr('data');
					$(".sorting-option").removeClass("selected");
					$this.addClass("selected");

					sortAndRender(playlist, countField);

				});

				renderPlaylistInfo(playlist);
				sortAndRender(playlist, "viewCount");

				//$(".number-of-videos").html(playlist.length);

			});

    </script>
</header>
<body>
<div class="container">
    <header class="playlist-info">
        <h1 class="playlist-title">Play list</h1>
    </header>
    <span class="label number-of-videos"></span>
    <ul class="sorting-menu">
        <li><a class="sorting-option" data="commentCount" href="">comments</a></li>
        <li><a class="sorting-option" data="favoriteCount" href="">favorites</a></li>
        <li><a class="sorting-option" data="dislikeCount" href="">dislikes</a></li>
        <li><a class="sorting-option selected" data="viewCount" href="">views</a></li>
    </ul>
    <ul class="playlist">

    </ul>
</div>
</body>
</html>